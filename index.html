<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Bible Styler ... browser edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no">
  <style>
    :root {
      --bg: #0b0f14;
      --bg-elev: #0f172a;
      --bg-input: #0b1220;
      --border: #1e293b;
      --border-strong: #334155;
      --text: #e5e7eb;
      --text-muted: #94a3b8;
      --accent: #38bdf8;
      --accent-2: #22d3ee;
      --danger: #f43f5e;
      --ok: #34d399;
      --term: #a7f3d0;
      --term-bg: #071019;
      --focus: 0 0 0 3px rgba(56, 189, 248, 0.35);
      --radius: 12px;
      --font-mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --font-sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      /* button theming defaults (dark) */
      --btn-bg: var(--accent);
      --btn-bg-2: var(--accent-2);
      --btn-fg: #001018;
      --btn-secondary-fg: var(--text);
      --btn-danger-top: #fb7185;
      --btn-danger-bg: var(--danger);
      --btn-danger-fg: #1b0310;
      --btn-ok-top: #6ee7b7;
      --btn-ok-bg: var(--ok);
      --btn-ok-fg: #032018;
      /* compact button sizing */
      --btn-py: 8px;
      --btn-px: 12px;
      --btn-font: 14px;
      --btn-min-h: 40px;
      --btn-radius: 8px;
      /* neutral button palette */
      --btn-neutral-bg: #4b5563;
      --btn-neutral-bg-2: #374151;
      --btn-neutral-fg: #f3f4f6;
      --btn-neutral-border: #6b7280;
      /* link color */
      --link: #16a34a;
    }
    html, body {
      background: var(--bg);
      color: var(--text);
      margin: 0; padding: 0;
      font-family: var(--font-sans);
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    body {
      padding: 24px;
      padding-left: max(16px, env(safe-area-inset-left));
      padding-right: max(16px, env(safe-area-inset-right));
      padding-bottom: max(16px, env(safe-area-inset-bottom));
    }
    h1 { margin: 0 0 12px 0; font-size: 20px; letter-spacing: 0.2px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .row { grid-column: 1 / -1; }
    .card { border: 1px solid var(--border); border-radius: var(--radius); padding: 14px; background: var(--bg-elev); box-shadow: 0 1px 0 rgba(255,255,255,0.02) inset, 0 0 0 1px rgba(255,255,255,0.02); }
    .grid > * { min-width: 0; }
    label { font-size: 12px; display: block; margin-bottom: 6px; color: var(--text-muted); }
    input, textarea, select, button { font: inherit; color: inherit; }
    input, textarea, select {
      width: 100%; box-sizing: border-box; padding: 12px 14px;
      border: 1px solid var(--border-strong); border-radius: 10px; background: var(--bg-input);
      color: var(--text); outline: none; transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
      font-size: 16px; line-height: 1.2;  /* avoid iOS zoom */
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    input::placeholder, textarea::placeholder { color: #6b7280; }
    input:focus, textarea:focus, select:focus { border-color: var(--accent); box-shadow: var(--focus); }
    textarea { min-height: 120px; resize: vertical; }
    .mono { font-family: var(--font-mono); }
    .btn {
      padding: var(--btn-py) var(--btn-px); border: 1px solid var(--btn-bg-2); border-radius: var(--btn-radius);
      background: linear-gradient(180deg, var(--btn-bg) 0%, var(--btn-bg-2) 100%);
      color: var(--btn-fg); cursor: pointer; font-weight: 600; transition: filter 120ms ease, transform 60ms ease; user-select: none;
      min-height: var(--btn-min-h); /* touch target */
      font-size: var(--btn-font);
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { background: transparent; color: var(--btn-secondary-fg); border-color: var(--border-strong); }
    .btn.danger { border-color: var(--btn-danger-bg); background: linear-gradient(180deg, var(--btn-danger-top) 0%, var(--btn-danger-bg) 100%); color: var(--btn-danger-fg); }
    .btn.ok { border-color: var(--btn-ok-bg); background: linear-gradient(180deg, var(--btn-ok-top) 0%, var(--btn-ok-bg) 100%); color: var(--btn-ok-fg); }
    .btn.neutral { border-color: var(--btn-neutral-border); background: linear-gradient(180deg, var(--btn-neutral-bg) 0%, var(--btn-neutral-bg-2) 100%); color: var(--btn-neutral-fg); }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }
    .inline { display: inline-flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .muted { color: var(--text-muted); font-size: 12px; }
    .out { white-space: pre-wrap; font-family: var(--font-mono); background: var(--term-bg); color: var(--term); padding: 14px; border-radius: 10px; min-height: 180px; border: 1px solid var(--border-strong); }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; background: var(--bg-input); color: var(--accent); border: 1px solid var(--accent-2); font-size: 11px; font-weight: 600; }
    .tabs { display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
    .tab { padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border-strong); cursor: pointer; user-select: none; background: var(--bg-input); min-height: 40px; display: inline-flex; align-items: center; color: var(--text); }
    .tab.active { border-color: var(--accent); box-shadow: var(--focus); background: var(--bg-elev); }
    /* details-like toggle styling */
    #setupSummary button.btn.secondary { min-width: 180px; }
    /* links */
    a, a:visited { color: var(--link) !important; }
    a { text-decoration: none; }
    a:hover, a:focus { text-decoration: underline; }
    @media (max-width: 920px) {
      body { padding: 16px; }
      .grid { grid-template-columns: repeat(6, 1fr); gap: 10px; }
    }
    @media (max-width: 640px) {
      .grid { grid-template-columns: repeat(4, 1fr); gap: 8px; }
      /* Force grid items to stack to avoid overlaps from inline grid-column spans */
      .grid > * { grid-column: 1 / -1 !important; }
      .inline { gap: 6px; }
      label { margin-bottom: 4px; }
      input, textarea, select { font-size: 16px; }
      .btn { width: 100%; justify-content: center; }
    }
  </style>
</head>
<body>
  <h1>Bible Styler ... browser edition <span class="badge" id="themeBadge">dark</span></h1>
  <div class="muted" style="margin: 6px 0 12px 0;">
    If this helps you, consider supporting:
    <a href="https://ko-fi.com/gille" target="_blank" rel="noopener">ko-fi.com/gille</a>
    &nbsp;•&nbsp;
    <a href="https://github.com/helix4u/Bible-Styler/blob/main/README.md" target="_blank" rel="noopener">README</a>
  </div>

  <div class="grid">
    <!-- Setup summary toggle -->
    <div class="row card" id="setupSummary">
      <div class="inline" style="justify-content: space-between; width:100%;">
        <div class="inline">
          <button id="setupToggle" class="btn secondary" aria-expanded="false" aria-controls="setupApiCard setupDataCard">Setup & Settings ▸</button>
          <span class="muted">API, models, persona, data, options</span>
        </div>
        <div class="inline">
          <label for="themeSelect" style="margin:0;">Theme</label>
          <select id="themeSelect"></select>
        </div>
      </div>
    </div>

    <!-- provider presets and api config -->
    <div class="row card" id="setupApiCard" style="display:none;">
      <div class="grid">
        <div style="grid-column: span 4;">
          <label for="vendor">Vendor preset</label>
          <select id="vendor">
            <option>Custom</option>
            <option>LM Studio ... local</option>
            <option>Ollama ... OpenAI compat</option>
            <option>OpenAI</option>
            <option>OpenRouter</option>
            <option>Together</option>
            <option>Groq</option>
            <option>Fireworks</option>
            <option>DeepInfra</option>
            <option>Cerebras</option>
          </select>
        </div>
        <div style="grid-column: span 5;">
          <label for="apiBase">API base ... OpenAI compatible chat completions</label>
          <input id="apiBase" placeholder="Example: http://127.0.0.1:1234/v1/chat/completions" spellcheck="false" autocomplete="off">
        </div>
        <div style="grid-column: span 3;">
          <label>Fetch models</label>
          <div class="inline">
            <button id="fetchModels" class="btn secondary">Fetch</button>
            <span id="modelsStatus" class="muted" aria-live="polite"></span>
          </div>
        </div>

        <div style="grid-column: span 6;">
          <label for="apiKey">API key ... stored only in this browser</label>
          <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off">
        </div>

        <div style="grid-column: span 6;">
          <label for="themeOverrides">Theme overrides (CSS vars JSON) ... optional</label>
          <textarea id="themeOverrides" class="mono" placeholder='{"--accent":"#22d3ee","--bg":"#0b0f14"}'></textarea>
        </div>

        <!-- model selector with mobile-safe select and an optional free-typing input -->
        <div style="grid-column: span 3;">
          <label for="modelSelect">Model</label>
          <select id="modelSelect"></select>
          <input id="modelText" style="display:none; margin-top:8px;" placeholder="type a model id..." spellcheck="false" autocomplete="off">
          <div class="inline" style="margin-top:6px;">
            <input id="customModelToggle" type="checkbox" style="width:auto;">
            <label for="customModelToggle" style="margin:0;">type custom</label>
          </div>
        </div>

        <div style="grid-column: span 3;">
          <label for="temperature">Temperature</label>
          <input id="temperature" type="number" step="0.1" min="0" max="2" value="0.9">
        </div>

        <div style="grid-column: span 3;">
          <label for="stream">Stream tokens</label>
          <select id="stream">
            <option value="true" selected>true</option>
            <option value="false">false</option>
          </select>
        </div>
        <div style="grid-column: span 9;">
          <label for="extraHeaders">Extra headers ... JSON object ... optional</label>
          <textarea id="extraHeaders" class="mono" placeholder='{"HTTP-Referer":"https://your.site","X-Title":"Bible Styler"}'></textarea>
        </div>

        <div style="grid-column: span 12;">
          <label for="systemPrompt">Style system prompt</label>
          <textarea id="systemPrompt" class="mono"></textarea>
        </div>

        <!-- personas: presets + save slots -->
        <div style="grid-column: span 12;">
          <div class="grid">
            <div style="grid-column: span 6;">
              <label for="presetSelect">Built-in presets</label>
              <div class="inline">
                <select id="presetSelect">
                  <option value="stoner">Stoner (default)</option>
                  <option value="zoomer">Zoomer</option>
                  <option value="houseish">Cynical TV Doctor (House-ish)</option>
                  <option value="plain">Plain English</option>
                  <option value="kid">Kid-Friendly</option>
                  <option value="headline">Headline</option>
                  <option value="legal">Legal Brief</option>
                  <option value="study">Study Note</option>
                  <option value="clinical">Clinical/Scientific</option>
                  <option value="minimalist">Minimalist</option>
                  <option value="tweet">Tweet-Length</option>
                  <option value="bard">Bold Bard</option>
                  <option value="pirate">Pirate</option>
                  <option value="noir">Noir Detective</option>
                  <option value="coach">Sports Coach</option>
                  <option value="stoic">Stoic Sage</option>
                  <option value="hacker">Hacker Log</option>
                </select>
                <button id="applyPreset" class="btn secondary">Apply preset</button>
              </div>
            </div>
            <div style="grid-column: span 6;">
              <label>Saved persona slots (local to this browser)</label>
              <div class="inline">
                <select id="slotSelect"></select>
                <button id="saveSlot" class="btn">Save to slot</button>
                <button id="loadSlot" class="btn secondary">Load slot</button>
                <button id="renameSlot" class="btn secondary">Rename</button>
                <button id="clearSlot" class="btn danger">Clear</button>
              </div>
            </div>
          </div>
        </div>

        <div style="grid-column: span 12;">
          <label for="stops">Stops ... comma separated</label>
          <input id="stops" value="Reference:,AI:,---">
        </div>
      </div>
      <div class="muted">Do not commit keys. This page saves to localStorage on this device only.</div>
    </div>
    
    <div class="row card" id="httpsWarn" style="display:none;">
      Heads up ... this page is HTTPS. Calls to http://localhost are often blocked by browsers. Prefer an HTTPS API endpoint or test the page locally over http.
    </div>

    <!-- data source -->
    <div class="row card" id="setupDataCard" style="display:none;">
      <div class="grid">
        <div style="grid-column: span 8;">
          <label for="jsonPreset">Default sources</label>
          <select id="jsonPreset"></select>
        </div>
        <div style="grid-column: span 8;">
          <label for="jsonUrl">Scripture JSON URL</label>
          <input id="jsonUrl" class="mono" value="https://raw.githubusercontent.com/johngthecreator/Book_of_Mormon_Scriptures/main/standard-works.json" spellcheck="false">
        </div>
        <div style="grid-column: span 4;">
          <label>Load JSON</label>
          <div class="inline">
            <button id="loadJson" class="btn secondary">Fetch</button>
            <input id="jsonFile" type="file" accept=".json">
          </div>
        </div>
        <div style="grid-column: span 4;">
          <label for="autoFetchJson">Auto-fetch JSON on load</label>
          <select id="autoFetchJson">
            <option value="false">false</option>
            <option value="true">true</option>
          </select>
        </div>
        <div style="grid-column: span 6;">
          <label for="volumes">Include volumes ... e.g. Old Testament,New Testament</label>
          <input id="volumes" value="Old Testament,New Testament">
        </div>
        <div style="grid-column: span 6;">
          <label for="books">Limit to books ... optional ... e.g. Genesis,Exodus</label>
          <input id="books" placeholder="Genesis,Exodus">
        </div>
        <div style="grid-column: span 4;">
          <label for="startIndex">Start index ... 0 based</label>
          <input id="startIndex" type="number" min="0" value="0">
        </div>
        <div style="grid-column: span 4;">
          <label for="endIndex">End before index ... optional</label>
          <input id="endIndex" type="number" min="0" placeholder="">
        </div>
        <div style="grid-column: span 4;">
          <label for="ctxPairs">Context pairs memory</label>
          <input id="ctxPairs" type="number" min="0" value="3">
        </div>
      </div>
      <div class="muted">JSON must be an array with keys ... book_title, chapter_number, verse_number, scripture_text.</div>
    </div>

    <!-- mode tabs -->
    <div class="row card">
      <div class="tabs">
        <div class="tab" data-panel="batchPanel" tabindex="0">Batch mode</div>
        <div class="tab active" data-panel="singlePanel" tabindex="0">Single verse/chapter</div>
      </div>

      <div id="batchPanel" style="display:none;">
        <div class="inline" style="margin-bottom: 8px;">
          <button id="startBtn" class="btn">Start</button>
          <button id="stopBtn" class="btn danger" disabled>Stop</button>
          <button id="downloadBtn" class="btn secondary" disabled>Download .txt</button>
        </div>
        <div id="status" class="muted" style="margin-top:8px;" aria-live="polite"></div>
      </div>

      <div id="singlePanel" style="display:block;">
        <div class="grid" style="margin-bottom: 8px;">
          <div style="grid-column: span 4;">
            <label for="bookSel">Book</label>
            <select id="bookSel"></select>
          </div>
          <div style="grid-column: span 4;">
            <label for="chapterSel">Chapter</label>
            <select id="chapterSel"></select>
          </div>
          <div style="grid-column: span 4;">
            <label for="verseSel">Verse</label>
            <select id="verseSel"></select>
          </div>
          <div style="grid-column: span 12;">
            <label for="singleText">Text override ... optional</label>
            <textarea id="singleText" class="mono" placeholder="Leave empty to use text from JSON"></textarea>
          </div>
        </div>
        <div class="inline" style="margin-bottom: 8px;">
          <button id="runSingle" class="btn ok">Run single verse</button>
          <button id="runChapter" class="btn neutral">Run chapter</button>
        </div>
        <div id="singleStatus" class="muted" aria-live="polite"></div>
      </div>
    </div>

    <!-- output -->
    <div class="row card">
      <label>Output</label>
      <div class="inline" style="margin: 8px 0;">
        <button id="copyOut" class="btn secondary">Copy output</button>
        <button id="shareOut" class="btn neutral">Share</button>
        <span id="outStatus" class="muted" aria-live="polite"></span>
      </div>
      <div id="out" class="out"></div>
    </div>
  </div>

  <script>
    // ---------- helpers
    function normalizeAscii(s) {
      return String(s)
        .replace(/\u2018|\u2019/g, "'")
        .replace(/\u201C|\u201D/g, '"')
        .replace(/\u2013|\u2014/g, "...")
        .replace(/\u00A0/g, " ");
    }
    function sanitizeOneLine(s) {
      if (!s) return "";
      s = normalizeAscii(s);
      s = s.replace(/\r/g, " ").replace(/\n/g, " ").trim();
      s = s.replace(/\s*---.*$/i, "");
      s = s.replace(/^\s*(AI|Answer|Output)\s*:\s*/i, "");
      s = s.replace(/\s*Reference\s*:.*$/i, "");
      s = Array.from(s).filter(ch => ch.codePointAt(0) < 0x2500).join("");
      return s.trim();
    }
    function refString(book, chapter, verse) { return `${book} ${chapter}:${verse}`; }
    function openingNgram(s, n = 4) {
      const toks = s.trim().split(/\s+/).filter(Boolean);
      return toks.slice(0, n).join(" ").toLowerCase();
    }
    function parseJSONOrEmpty(str) {
      const t = String(str || '').trim();
      if (!t) return {};
      try { return JSON.parse(t); } catch { return {}; }
    }

    // ---------- persona presets
    const PRESET_TEXTS = {
      stoner:
`You are rewriting each Bible verse in a stoner voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Do not narrate what you are doing. Just do it.. and do it with exaggerated tone.`,
      zoomer:
`You are rewriting each Bible verse in a zoomer voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Use tight, internet-native phrasing with occasional slang and lowercasing where natural, but keep names correctly cased. No emojis. No slurs.`,
      houseish:
`You are rewriting each Bible verse in the voice of a cynical, brilliant diagnostician from a medical drama. Dry, acerbic, brutally honest, skeptical of neat moral explanations, but precise. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Inject cutting diagnostic metaphors and bleak wit, but stay faithful to facts. No emojis. No slurs.`,

      // --- useful/accessible tones
      plain:
`You are rewriting each Bible verse in plain modern English. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Short, clear sentences. Make every line unique. No Repetition. No emojis. No slurs.`,
      kid:
`You are rewriting each Bible verse for kids. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Use simple words and short, friendly phrases. Make every line unique. No Repetition. No emojis. No slurs.`,
      headline:
`You are rewriting each Bible verse as a news headline. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Compact and punchy; ~12-18 words. Make every line unique. No Repetition. No emojis. No slurs.`,
      legal:
`You are rewriting each Bible verse in the tone of a formal legal brief. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Precise, neutral wording; use whereas/therefore sparingly. Make every line unique. No Repetition. No emojis. No slurs.`,
      study:
`You are rewriting each Bible verse as a concise study note. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Clarify relationships with plain connectors (because, therefore, but). Make every line unique. No Repetition. No emojis. No slurs.`,
      clinical:
`You are rewriting each Bible verse in a clinical, scientific tone. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Neutral cause-and-effect phrasing; avoid metaphor. Make every line unique. No Repetition. No emojis. No slurs.`,
      minimalist:
`You are rewriting each Bible verse in a minimalist style. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. 15-25 words max; remove filler; keep structure clear. Make every line unique. No Repetition. No emojis. No slurs.`,
      tweet:
`You are rewriting each Bible verse as a tweet-length line (<=180 chars). Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. No emojis. No slurs.`,

      // --- fun/voicey tones
      bard:
`You are rewriting each Bible verse in a Shakespeare-like bardic voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Use thee/thy/'tis where natural. Make every line unique. No Repetition. No emojis. No slurs.`,
      pirate:
`You are rewriting each Bible verse in a clean pirate voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Light nautical slang; no profanity. Make every line unique. No Repetition. No emojis. No slurs.`,
      noir:
`You are rewriting each Bible verse in a noir detective voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Short, moody, hardboiled cadence. Make every line unique. No Repetition. No emojis. No slurs.`,
      coach:
`You are rewriting each Bible verse as a sports coach pep-talk. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Upbeat, imperative metaphors; clean language. Make every line unique. No Repetition. No emojis. No slurs.`,
      stoic:
`You are rewriting each Bible verse in a stoic, aphoristic voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Calm, terse, disciplined tone. Make every line unique. No Repetition. No emojis. No slurs.`,
      hacker:
`You are rewriting each Bible verse like a concise system log. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Use bracketed tags and status-like phrasing sparingly. Make every line unique. No Repetition. No emojis. No slurs.`
    };

    // ---------- themes
    const THEMES = {
      dark: {
        '--bg':'#0b0f14','--bg-elev':'#0f172a','--bg-input':'#0b1220','--border':'#1e293b','--border-strong':'#334155','--text':'#e5e7eb','--text-muted':'#94a3b8','--accent':'#38bdf8','--accent-2':'#22d3ee','--danger':'#f43f5e','--ok':'#34d399','--term':'#a7f3d0','--term-bg':'#071019',
        '--btn-bg':'#38bdf8','--btn-bg-2':'#22d3ee','--btn-fg':'#001018','--btn-secondary-fg':'#e5e7eb',
        '--btn-danger-top':'#fb7185','--btn-danger-bg':'#f43f5e','--btn-danger-fg':'#1b0310',
        '--btn-ok-top':'#6ee7b7','--btn-ok-bg':'#34d399','--btn-ok-fg':'#032018',
        '--link':'#22c55e'
      },
      light: {
        '--bg':'#f8fafc','--bg-elev':'#ffffff','--bg-input':'#f1f5f9','--border':'#e5e7eb','--border-strong':'#cbd5e1','--text':'#0f172a','--text-muted':'#475569','--accent':'#0ea5e9','--accent-2':'#22d3ee','--danger':'#dc2626','--ok':'#059669','--term':'#0f172a','--term-bg':'#e2e8f0',
        '--btn-bg':'#0ea5e9','--btn-bg-2':'#22d3ee','--btn-fg':'#0f172a','--btn-secondary-fg':'#0f172a',
        '--btn-danger-top':'#fca5a5','--btn-danger-bg':'#dc2626','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#a7f3d0','--btn-ok-bg':'#059669','--btn-ok-fg':'#ffffff',
        '--link':'#15803d'
      },
      cyberpunk: {
        '--bg':'#0a1420','--bg-elev':'#0f1f30','--bg-input':'#0c1a2b','--border':'#203349','--border-strong':'#2f4b63','--text':'#cde7ff','--text-muted':'#6aa0bb','--accent':'#00eaff','--accent-2':'#00b7ff','--danger':'#ff2d55','--ok':'#00ffa3','--term':'#00eaff','--term-bg':'#071321',
        '--btn-bg':'#00eaff','--btn-bg-2':'#00b7ff','--btn-fg':'#001018','--btn-secondary-fg':'#9de9ff',
        '--btn-danger-top':'#ff506e','--btn-danger-bg':'#ff2d55','--btn-danger-fg':'#1f0a12',
        '--btn-ok-top':'#33ffb7','--btn-ok-bg':'#00ffa3','--btn-ok-fg':'#001a12',
        '--link':'#00ffa3'
      },
      onyx: {
        '--bg':'#000000','--bg-elev':'#0a0a0a','--bg-input':'#0f0f10','--border':'#1a1a1b','--border-strong':'#2a2a2b','--text':'#e6e6e6','--text-muted':'#9ca3af','--accent':'#9ca3af','--accent-2':'#6b7280','--danger':'#ef4444','--ok':'#10b981','--term':'#c7d2fe','--term-bg':'#060606',
        '--btn-bg':'#22d3ee','--btn-bg-2':'#22d3ee','--btn-fg':'#ffffff','--btn-secondary-fg':'#e6e6e6',
        '--btn-danger-top':'#fb7185','--btn-danger-bg':'#ef4444','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#6ee7b7','--btn-ok-bg':'#10b981','--btn-ok-fg':'#051b12',
        '--link':'#9ca3af',
        '--focus':'0 0 0 3px rgba(156, 163, 175, 0.35)'
      },
      sepia: {
        '--bg':'#f7f2e7','--bg-elev':'#fffdf7','--bg-input':'#f2eadf','--border':'#e8dcc6','--border-strong':'#d6c7ad','--text':'#2f2a24','--text-muted':'#6b5e52','--accent':'#b26b00','--accent-2':'#d97706','--danger':'#b45309','--ok':'#7c3aed','--term':'#3b2f2f','--term-bg':'#efe6d8',
        '--btn-bg':'#b26b00','--btn-bg-2':'#d97706','--btn-fg':'#2f2a24','--btn-secondary-fg':'#2f2a24',
        '--btn-danger-top':'#f59e0b','--btn-danger-bg':'#b45309','--btn-danger-fg':'#2f2a24',
        '--btn-ok-top':'#c4b5fd','--btn-ok-bg':'#7c3aed','--btn-ok-fg':'#ffffff',
        '--link':'#2f7d32'
      },
      highcontrast: {
        '--bg':'#000000','--bg-elev':'#000000','--bg-input':'#000000','--border':'#ffffff','--border-strong':'#ffffff','--text':'#ffffff','--text-muted':'#cfcfcf','--accent':'#ffff00','--accent-2':'#00ffff','--danger':'#ff0000','--ok':'#00ff00','--term':'#ffffff','--term-bg':'#000000',
        '--btn-bg':'#ffff00','--btn-bg-2':'#00ffff','--btn-fg':'#000000','--btn-secondary-fg':'#ffffff',
        '--btn-danger-top':'#ff7f7f','--btn-danger-bg':'#ff0000','--btn-danger-fg':'#000000',
        '--btn-ok-top':'#a7ffa7','--btn-ok-bg':'#00ff00','--btn-ok-fg':'#000000',
        '--link':'#00ff00'
      }
    };
    function applyTheme(name, overrides) {
      const root = document.documentElement;
      const base = THEMES[name] || THEMES.dark;
      Object.entries(base).forEach(([k,v]) => root.style.setProperty(k, v));
      if (overrides && typeof overrides === 'object') {
        Object.entries(overrides).forEach(([k,v]) => {
          if (String(k).startsWith('--')) root.style.setProperty(k, v);
        });
      }
      const badge = document.getElementById('themeBadge');
      if (badge) badge.textContent = name;
    }

    // ---------- vendor presets
    const vendorPresets = {
      "Custom": {},
      "LM Studio ... local": { apiBase: "http://127.0.0.1:1234/v1/chat/completions" },
      "Ollama ... OpenAI compat": { apiBase: "http://127.0.0.1:11434/v1/chat/completions" },
      "OpenAI": { apiBase: "https://api.openai.com/v1/chat/completions" },
      "OpenRouter": {
        apiBase: "https://openrouter.ai/api/v1/chat/completions",
        extraHeaders: { "HTTP-Referer": location.origin || "https://example.com", "X-Title": "Bible Styler" }
      },
      "Together": { apiBase: "https://api.together.xyz/v1/chat/completions" },
      "Groq": { apiBase: "https://api.groq.com/openai/v1/chat/completions" },
      "Fireworks": { apiBase: "https://api.fireworks.ai/inference/v1/chat/completions" },
      "DeepInfra": { apiBase: "https://api.deepinfra.com/v1/openai/chat/completions" },
      "Cerebras": { apiBase: "https://api.cerebras.ai/v1/chat/completions" }
    };

    // ---------- UI refs
    const vendorEl = document.getElementById('vendor');
    const apiBaseEl = document.getElementById('apiBase');
    const apiKeyEl = document.getElementById('apiKey');
    const themeSelectEl = document.getElementById('themeSelect');
    const themeOverridesEl = document.getElementById('themeOverrides');
    const setupToggleBtn = document.getElementById('setupToggle');
    const setupApiCard = document.getElementById('setupApiCard');
    const setupDataCard = document.getElementById('setupDataCard');
    const autoFetchJsonEl = document.getElementById('autoFetchJson');

    const modelSelectEl = document.getElementById('modelSelect');
    const modelTextEl = document.getElementById('modelText');
    const customModelToggle = document.getElementById('customModelToggle');

    const fetchModelsBtn = document.getElementById('fetchModels');
    const modelsStatus = document.getElementById('modelsStatus');

    const temperatureEl = document.getElementById('temperature');
    const streamEl = document.getElementById('stream');
    const systemPromptEl = document.getElementById('systemPrompt');
    const stopsEl = document.getElementById('stops');
    const extraHeadersEl = document.getElementById('extraHeaders');

    const presetSelect = document.getElementById('presetSelect');
    const applyPresetBtn = document.getElementById('applyPreset');
    const slotSelect = document.getElementById('slotSelect');
    const saveSlotBtn = document.getElementById('saveSlot');
    const loadSlotBtn = document.getElementById('loadSlot');
    const renameSlotBtn = document.getElementById('renameSlot');
    const clearSlotBtn = document.getElementById('clearSlot');

    const jsonUrlEl = document.getElementById('jsonUrl');
    const jsonPresetEl = document.getElementById('jsonPreset');
    const loadJsonBtn = document.getElementById('loadJson');
    const jsonFileEl = document.getElementById('jsonFile');
    const volumesEl = document.getElementById('volumes');
    const booksEl = document.getElementById('books');
    const startIndexEl = document.getElementById('startIndex');
    const endIndexEl = document.getElementById('endIndex');
    const ctxPairsEl = document.getElementById('ctxPairs');

    const outEl = document.getElementById('out');
    const copyOutBtn = document.getElementById('copyOut');
    const shareOutBtn = document.getElementById('shareOut');
    const outStatus = document.getElementById('outStatus');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusEl = document.getElementById('status');

    const tabs = document.querySelectorAll('.tab');
    const batchPanel = document.getElementById('batchPanel');
    const singlePanel = document.getElementById('singlePanel');
    const bookSel = document.getElementById('bookSel');
    const chapterSel = document.getElementById('chapterSel');
    const verseSel = document.getElementById('verseSel');
    const singleTextEl = document.getElementById('singleText');
    const runSingleBtn = document.getElementById('runSingle');
    const runChapterBtn = document.getElementById('runChapter');
    const singleStatus = document.getElementById('singleStatus');

    const httpsWarn = document.getElementById('httpsWarn');
    if (location.protocol === 'https:') httpsWarn.style.display = 'block';

    // clipboard + share helpers
    async function copyToClipboard(text) {
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
        } else {
          const ta = document.createElement('textarea');
          ta.value = text; ta.setAttribute('readonly', '');
          ta.style.position = 'fixed'; ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }
        return true;
      } catch { return false; }
    }
    function setOutStatus(msg) {
      outStatus.textContent = msg;
      if (!msg) return;
      setTimeout(() => { if (outStatus.textContent === msg) outStatus.textContent = ''; }, 2000);
    }
    async function shareOutput() {
      try {
        const txt = (outEl.textContent || '').trim();
        if (!txt) { setOutStatus('Nothing to share'); return; }
        // Text-only share (no file). Prefer native Web Share text path.
        if (navigator.share) {
          const snippet = txt.length > 100000 ? txt.slice(0, 100000) : txt;
          try {
            await navigator.share({ title: 'Styled Bible', text: snippet });
            setOutStatus('Shared');
            return;
          } catch (err) {
            if (err && (err.name === 'AbortError' || err.name === 'NotAllowedError')) { setOutStatus(''); return; }
          }
        }
        // Fallback: copy to clipboard
        const ok = await copyToClipboard(txt);
        setOutStatus(ok ? 'Copied (share unavailable)' : 'Share/copy failed');
      } catch (e) {
        setOutStatus('Share failed');
      }
    }

    // helper: set and persist active panel (batchPanel | singlePanel)
    function setActivePanel(panel) {
      const list = Array.from(tabs);
      list.forEach(x => x.classList.remove('active'));
      const tab = list.find(x => x.dataset.panel === panel) || list[0];
      if (tab) tab.classList.add('active');
      batchPanel.style.display = panel === 'batchPanel' ? 'block' : 'none';
      singlePanel.style.display = panel === 'singlePanel' ? 'block' : 'none';
      try {
        const prev = (() => { try { return JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}'); } catch { return {}; } })();
        prev.activePanel = panel;
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(prev));
      } catch {}
    }

    // tabs toggle...use pointerup for better mobile behavior
    tabs.forEach(t => {
      const handler = () => {
        const panel = t.dataset.panel;
        setActivePanel(panel);
      };
      ['pointerup','click','keyup'].forEach(ev => t.addEventListener(ev, (e) => {
        if (ev === 'keyup' && e.key !== 'Enter' && e.key !== ' ') return;
        handler();
      }, { passive: true }));
    });

    // ---------- persistence
    const SETTINGS_KEY = 'bibleStylerSettings.v2';
    const SLOTS_KEY = 'personaSlots.v1'; // 5 slots
    let setupOpen = false;

    function getActiveModelId() {
      return customModelToggle.checked ? modelTextEl.value.trim() : modelSelectEl.value.trim();
    }

    function saveSettings() {
      const obj = {
        vendor: vendorEl.value,
        apiBase: apiBaseEl.value,
        apiKey: apiKeyEl.value,
        themeName: (themeSelectEl?.value || 'dark'),
        themeOverrides: (themeOverridesEl?.value || ''),
        setupOpen: !!setupOpen,
        modelMode: customModelToggle.checked ? 'custom' : 'select',
        modelSelect: modelSelectEl.value,
        modelText: modelTextEl.value,
        temperature: temperatureEl.value,
        stream: streamEl.value,
        systemPrompt: systemPromptEl.value,
        stops: stopsEl.value,
        jsonUrl: jsonUrlEl.value,
        autoFetchJson: (autoFetchJsonEl?.value || 'false'),
        volumes: volumesEl.value,
        books: booksEl.value,
        ctxPairs: ctxPairsEl.value,
        extraHeaders: extraHeadersEl.value,
        // persist current panel selection as part of settings
        activePanel: (document.querySelector('.tab.active')?.dataset.panel) || 'singlePanel'
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj));
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (raw) {
          const s = JSON.parse(raw);
          vendorEl.value = s.vendor || 'Custom';
          apiBaseEl.value = s.apiBase || '';
          apiKeyEl.value = s.apiKey || '';
          // theme
          const themeName = (s.themeName || 'dark');
          const themeOverrides = (() => { try { return JSON.parse(s.themeOverrides||''); } catch { return {}; }})();
          initThemeUI(themeName);
          applyTheme(themeName, themeOverrides);
          if (themeOverridesEl) themeOverridesEl.value = s.themeOverrides || '';
          setupOpen = !!s.setupOpen;
          setSetupOpen(setupOpen);
          temperatureEl.value = s.temperature || '0.9';
          streamEl.value = s.stream || 'true';
          systemPromptEl.value = s.systemPrompt || PRESET_TEXTS.stoner; // default
          stopsEl.value = s.stops || 'Reference:,AI:,---';
          jsonUrlEl.value = s.jsonUrl || jsonUrlEl.value;
          if (autoFetchJsonEl) autoFetchJsonEl.value = s.autoFetchJson || 'false';
          volumesEl.value = s.volumes || 'Old Testament,New Testament';
          booksEl.value = s.books || '';
          ctxPairsEl.value = s.ctxPairs || '3';
          extraHeadersEl.value = s.extraHeaders || '';
          // model mode
          const mode = s.modelMode || 'select';
          customModelToggle.checked = mode === 'custom';
          modelTextEl.value = s.modelText || '';
          modelSelectEl.value = s.modelSelect || '';
          updateModelInputsVisibility();
          // restore last active panel (batch vs single) — default single first
          setActivePanel(s.activePanel || 'singlePanel');
        } else {
          systemPromptEl.value = PRESET_TEXTS.stoner; // first load default
        }
      } catch {
        systemPromptEl.value = PRESET_TEXTS.stoner;
      }
    }

    function initThemeUI(selected) {
      if (!themeSelectEl) return;
      const options = [
        {v:'dark', t:'Dark'},
        {v:'light', t:'Light'},
        {v:'cyberpunk', t:'Cyberpunk'},
        {v:'onyx', t:'Onyx Black'},
        {v:'sepia', t:'Sepia'},
        {v:'highcontrast', t:'High Contrast'}
      ];
      themeSelectEl.innerHTML = options.map(o => `<option value="${o.v}">${o.t}</option>`).join('');
      themeSelectEl.value = options.some(o=>o.v===selected) ? selected : 'dark';
    }

    function setSetupOpen(open) {
      setupOpen = !!open;
      if (setupApiCard) setupApiCard.style.display = open ? 'block' : 'none';
      if (setupDataCard) setupDataCard.style.display = open ? 'block' : 'none';
      if (setupToggleBtn) {
        setupToggleBtn.textContent = open ? 'Setup & Settings ▾' : 'Setup & Settings ▸';
        setupToggleBtn.setAttribute('aria-expanded', String(open));
      }
      // Only show HTTPS warning when setup section is visible and protocol is https
      if (httpsWarn) httpsWarn.style.display = (open && location.protocol === 'https:') ? 'block' : 'none';
    }

    function updateModelInputsVisibility() {
      if (customModelToggle.checked) {
        modelTextEl.style.display = 'block';
        modelSelectEl.style.display = 'none';
      } else {
        modelTextEl.style.display = 'none';
        modelSelectEl.style.display = 'block';
      }
    }

    // persist most fields
    document.querySelectorAll('input,textarea,select').forEach(el => {
      el.addEventListener('change', saveSettings, { passive: true });
      el.addEventListener('input', saveSettings, { passive: true }); // save while typing to retain on refresh
    });
    // Setup toggle
    if (setupToggleBtn) {
      setupToggleBtn.addEventListener('pointerup', () => { setSetupOpen(!setupOpen); saveSettings(); });
    }
    // Theme handlers
    if (themeSelectEl) themeSelectEl.addEventListener('change', () => {
      const overrides = (() => { try { return JSON.parse(themeOverridesEl.value||''); } catch { return {}; } })();
      applyTheme(themeSelectEl.value, overrides);
      saveSettings();
    }, { passive: true });
    if (themeOverridesEl) themeOverridesEl.addEventListener('change', () => {
      const overrides = (() => { try { return JSON.parse(themeOverridesEl.value||''); } catch { return {}; } })();
      applyTheme((themeSelectEl?.value||'dark'), overrides);
      saveSettings();
    }, { passive: true });
    loadSettings();

    // ---------- persona slots
    function loadSlots() {
      try {
        const raw = localStorage.getItem(SLOTS_KEY);
        if (!raw) return Array.from({length:5}, () => ({name:'', prompt:''}));
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr) || arr.length !== 5) return Array.from({length:5}, () => ({name:'', prompt:''}));
        return arr.map(x => ({ name: String(x.name||''), prompt: String(x.prompt||'') }));
      } catch {
        return Array.from({length:5}, () => ({name:'', prompt:''}));
      }
    }
    function saveSlots(slots) { localStorage.setItem(SLOTS_KEY, JSON.stringify(slots)); }
    function updateSlotUI(slots) {
      slotSelect.innerHTML = '';
      slots.forEach((s, i) => {
        const label = s.name ? `Slot ${i+1}: ${s.name}` : `Slot ${i+1}: (empty)`;
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = label;
        slotSelect.appendChild(opt);
      });
      if (slotSelect.options.length) slotSelect.value = slotSelect.options[0].value;
    }

    let personaSlots = loadSlots();
    updateSlotUI(personaSlots);

    applyPresetBtn.addEventListener('pointerup', () => {
      const key = presetSelect.value;
      systemPromptEl.value = PRESET_TEXTS[key] || PRESET_TEXTS.stoner;
      saveSettings();
    });

    saveSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const current = personaSlots[idx] || {name:'', prompt:''};
      const suggested = current.name || (systemPromptEl.value.split('\n')[0].slice(0,48));
      const name = window.prompt('Name for this slot:', suggested) || suggested || `Persona ${idx+1}`;
      personaSlots[idx] = { name, prompt: systemPromptEl.value };
      saveSlots(personaSlots);
      updateSlotUI(personaSlots);
    });

    loadSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const slot = personaSlots[idx];
      if (!slot || !slot.prompt) { alert('Empty slot.'); return; }
      systemPromptEl.value = slot.prompt;
      saveSettings();
    });

    renameSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const slot = personaSlots[idx];
      if (!slot) return;
      const name = window.prompt('New name:', slot.name || `Persona ${idx+1}`);
      if (name != null) {
        personaSlots[idx].name = name.trim();
        saveSlots(personaSlots);
        updateSlotUI(personaSlots);
      }
    });

    clearSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const name = (personaSlots[idx]?.name || `Persona ${idx+1}`).trim() || `Persona ${idx+1}`;
      const ok = window.confirm(`Clear saved slot "${name}"? This cannot be undone.`);
      if (!ok) return;
      personaSlots[idx] = {name:'', prompt:''};
      saveSlots(personaSlots);
      updateSlotUI(personaSlots);
    });

    // ---------- apply vendor preset
    vendorEl.addEventListener('change', () => {
      const p = vendorPresets[vendorEl.value] || {};
      if (p.apiBase) apiBaseEl.value = p.apiBase;
      if (p.extraHeaders) {
        try {
          const existing = parseJSONOrEmpty(extraHeadersEl.value);
          const merged = Object.assign({}, existing, p.extraHeaders);
          extraHeadersEl.value = JSON.stringify(merged);
        } catch {
          extraHeadersEl.value = JSON.stringify(p.extraHeaders);
        }
      }
      saveSettings();
      modelsStatus.textContent = 'Preset applied';
    }, { passive: true });

    // ---------- Scripture data and selectors
    let verses = [];
    function norm(s) { return String(s || '').trim().toLowerCase(); }
    function parseList(s) {
      if (!s) return null;
      const parts = String(s).split(',').map(t => t.trim()).filter(Boolean);
      return parts.length ? parts : null;
    }
    function filterVerses(rows, volumes, books) {
      const volSet = volumes ? new Set(volumes.map(v => norm(v))) : null;
      const bookSet = books ? new Set(books.map(b => norm(b))) : null;
      const out = [];
      for (const it of rows) {
        const vol = norm(it.volume_title);
        const book = norm(it.book_title);
        if (volSet && !volSet.has(vol)) continue;
        if (bookSet && !bookSet.has(book)) continue;
        out.push(it);
      }
      return out;
    }
    async function fetchJson(url) {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }
    function updateVolumeBookFields(rows) {
      try {
        const vols = Array.from(new Set(rows.map(r => String(r.volume_title || '').trim()).filter(Boolean)));
        const books = Array.from(new Set(rows.map(r => String(r.book_title || '').trim()).filter(Boolean)));
        if (vols.length) volumesEl.value = vols.join(',');
        // Do not force all books (can be long). Leave empty but hint via placeholder.
        booksEl.value = '';
        if (books.length) {
          const hint = books.slice(0, 8).join(',') + (books.length > 8 ? ' ...' : '');
          booksEl.placeholder = hint || 'Genesis,Exodus';
        }
      } catch {}
    }
    // Default JSON sources list
    const DEFAULT_JSON_SOURCES = [
      {
        label: 'Standard Works (Book_of_Mormon_Scriptures)',
        url: 'https://raw.githubusercontent.com/johngthecreator/Book_of_Mormon_Scriptures/main/standard-works.json'
      },
      {
        label: 'Bhagavad Gita (helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/refs/heads/main/gita_standard_works.json'
      },
      { label: 'Custom URL...', url: '' }
    ];
    function initJsonPresetUI() {
      // populate options
      jsonPresetEl.innerHTML = '';
      DEFAULT_JSON_SOURCES.forEach((src, i) => {
        const opt = document.createElement('option');
        opt.value = src.url;
        opt.textContent = src.label;
        jsonPresetEl.appendChild(opt);
      });
      // select matching preset if any
      const current = (jsonUrlEl.value || '').trim();
      const match = DEFAULT_JSON_SOURCES.find(s => s.url && s.url === current);
      jsonPresetEl.value = match ? match.url : '';
      // on change, apply into the URL field
      jsonPresetEl.addEventListener('change', () => {
        const url = jsonPresetEl.value || '';
        if (url) jsonUrlEl.value = url;
        saveSettings();
      }, { passive: true });
    }
    initJsonPresetUI();
    function populateSelectorsFromData(rows) {
      const books = Array.from(new Set(rows.map(r => r.book_title)));
      bookSel.innerHTML = books.map(b => `<option value="${b}">${b}</option>`).join('');
      if (books.length) { bookSel.value = books[0]; populateChapters(); }
    }
    function populateChapters() {
      const b = bookSel.value;
      const chapters = Array.from(new Set(verses.filter(v => v.book_title === b).map(v => Number(v.chapter_number)))).sort((a,b)=>a-b);
      chapterSel.innerHTML = chapters.map(c => `<option value="${c}">${c}</option>`).join('');
      if (chapters.length) { chapterSel.value = chapters[0]; populateVerses(); }
    }
    function populateVerses() {
      const b = bookSel.value;
      const c = Number(chapterSel.value);
      const vs = verses
        .filter(v => v.book_title === b && Number(v.chapter_number) === c)
        .map(v => Number(v.verse_number))
        .sort((a,b)=>a-b);
      const prev = Number(verseSel.value);
      verseSel.innerHTML = vs.map(v => `<option value="${v}">${v}</option>`).join('');
      if (vs.includes(prev)) {
        verseSel.value = String(prev);
      } else if (vs.length) {
        verseSel.value = String(vs[0]);
      }
      updateSinglePlaceholder();
    }

    function updateSinglePlaceholder() {
      const b = bookSel.value;
      const c = Number(chapterSel.value);
      const vno = Number(verseSel.value);
      const txt = verses.find(v => v.book_title === b && Number(v.chapter_number) === c && Number(v.verse_number) === vno)?.scripture_text || '';
      // Show full original scripture text for mobile usability; do not truncate
      singleTextEl.placeholder = txt ? `JSON text: ${txt}` : 'No JSON text found';
    }

    function bindMobileSelect(sel, handler) {
      ['change','input','pointerup','click','blur'].forEach(ev => sel.addEventListener(ev, handler, { passive: true }));
    }

    async function loadJsonFromUrl() {
      try {
        statusEl.textContent = 'Fetching JSON...';
        const data = await fetchJson(jsonUrlEl.value);
        if (!Array.isArray(data) || !data.length) throw new Error('Expected JSON array');
        verses = data;
        statusEl.textContent = `Loaded ${data.length} rows`;
        populateSelectorsFromData(verses);
        updateVolumeBookFields(verses);
        saveSettings();
        return true;
      } catch (e) {
        statusEl.textContent = `Failed to load JSON ... ${e.message}`;
        return false;
      }
    }

    document.getElementById('loadJson').addEventListener('pointerup', loadJsonFromUrl);

    jsonFileEl.addEventListener('change', async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        if (!Array.isArray(data) || !data.length) throw new Error('Expected JSON array');
        verses = data;
        statusEl.textContent = `Loaded ${data.length} rows from file`;
        populateSelectorsFromData(verses);
        updateVolumeBookFields(verses);
        saveSettings();
      } catch (e) {
        statusEl.textContent = `Bad JSON file ... ${e.message}`;
      }
    });

    bindMobileSelect(bookSel, populateChapters);
    bindMobileSelect(chapterSel, populateVerses);
    bindMobileSelect(verseSel, updateSinglePlaceholder);

    // ---------- chat call (SSE or JSON)
    async function chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders }) {
      const headers = { 'Content-Type': 'application/json' };
      if (apiKey) {
        headers['Authorization'] = `Bearer ${apiKey}`;
        headers['X-API-Key'] = apiKey;
      }
      if (extraHeaders) Object.assign(headers, extraHeaders);

      const payload = {
        model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature,
        stream
      };
      if (stops && stops.length) payload.stop = stops;

      const resp = await fetch(apiBase, { method: 'POST', headers, body: JSON.stringify(payload) });
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`HTTP ${resp.status} ... ${txt.slice(0, 400)}`);
      }

      const ct = resp.headers.get('content-type') || '';
      if (!stream || ct.includes('application/json')) {
        const obj = await resp.json();
        return obj?.choices?.[0]?.message?.content?.trim() || '';
      }

      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buf = '';
      let out = '';
      for (;;) {
        const { value, done } = await reader.read();
        if (done) break;
        buf += decoder.decode(value, { stream: true });
        const parts = buf.split('\n\n');
        buf = parts.pop() || '';
        for (const chunk of parts) {
          const line = chunk.trim();
          if (!line) continue;
          const raw = line.startsWith('data: ') ? line.slice(6).trim() : line;
          if (raw === '[DONE]') { reader.cancel().catch(()=>{}); break; }
          try {
            const obj = JSON.parse(raw);
            const ch0 = obj.choices?.[0] || {};
            const piece = ch0.delta?.content ?? ch0.message?.content ?? '';
            if (piece) out += piece;
          } catch {}
        }
      }
      return out.trim();
    }

    function makeUserPrompt(book, chapter, verse, text) {
      return `Reference: ${book} ${chapter}:${verse}\nText: "${normalizeAscii(text)}"`;
    }
    function postprocessLine(result, expectedPrefix) {
      if (!result) return expectedPrefix;
      const safe = expectedPrefix.slice(1, -1).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const rx = new RegExp('\\[' + safe + '\\][^\\n\\r]*');
      const m = result.match(rx);
      let s = m ? m[0] : result;
      s = sanitizeOneLine(s);
      if (!s.startsWith(expectedPrefix)) {
        const body = s.replace(/^[\[\("]+/, '').trim();
        s = `${expectedPrefix} ${body}`;
      }
      return s;
    }
    function bodyOk(line, expectedPrefix, minChars = 6) {
      const body = line.slice(expectedPrefix.length).trim();
      return body.length >= minChars;
    }

    // ---------- fetch models (robust)
    async function fetchModelsList() {
      const apiBase = apiBaseEl.value.trim();
      const key = apiKeyEl.value.trim();
      if (!apiBase) throw new Error('API base required');

      const headers = { 'Accept': 'application/json' };
      if (key) headers['Authorization'] = `Bearer ${key}`;
      try { Object.assign(headers, parseJSONOrEmpty(extraHeadersEl.value)); } catch {}

      const baseRoot = apiBase
        .replace(/\/chat\/completions$/i, '')
        .replace(/\/+$/, '');
      const hasV1 = /\/v1$/i.test(baseRoot);

      const candidates = [
        `${baseRoot}/models`,
        hasV1 ? null : `${baseRoot}/v1/models`
      ].filter(Boolean);

      const isOllama = /localhost:11434|127\.0\.0\.1:11434/.test(apiBase);
      if (isOllama) candidates.push(apiBase.replace(/\/v1\/chat\/completions$/,'') + '/api/tags');

      let lastErr = 'no models endpoint responded';
      for (const url of candidates) {
        try {
          const r = await fetch(url, { headers });
          if (!r.ok) { lastErr = `HTTP ${r.status} at ${url}`; continue; }
          const data = await r.json();
          if (data && Array.isArray(data.data)) {
            return data.data.map(m => m.id || m.name).filter(Boolean);
          } else if (data && Array.isArray(data.models)) {
            return data.models.map(m => m.id || m.name).filter(Boolean);
          }
        } catch (e) { lastErr = e.message || String(e); }
      }
      throw new Error(lastErr);
    }

    fetchModelsBtn.addEventListener('pointerup', async () => {
      modelsStatus.textContent = 'Loading models...';
      // Remember selections before refresh
      const savedSelect = (() => { try { return (JSON.parse(localStorage.getItem(SETTINGS_KEY))||{}).modelSelect || ''; } catch { return ''; } })();
      const prevSelect = modelSelectEl.value;
      modelSelectEl.innerHTML = '';
      try {
        const ids = await fetchModelsList();
        if (!ids.length) throw new Error('no models returned');
        ids.forEach(id => {
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = id;
          modelSelectEl.appendChild(opt);
        });
        // Keep saved or previous selection if still present, otherwise pick first
        let chosen = '';
        if (savedSelect && ids.includes(savedSelect)) chosen = savedSelect;
        else if (prevSelect && ids.includes(prevSelect)) chosen = prevSelect;
        else if (ids.length) chosen = ids[0];
        if (chosen) modelSelectEl.value = chosen;
        modelsStatus.textContent = `Loaded ${ids.length}`;
        saveSettings();
      } catch (e) {
        modelsStatus.textContent = `Failed ... ${e.message}`;
      }
    });

    // toggle custom model typing
    customModelToggle.addEventListener('change', () => {
      updateModelInputsVisibility();
      saveSettings();
    }, { passive: true });

    // ---------- batch run
    let abort = false;
    startBtn.addEventListener('pointerup', async () => {
      try {
        abort = false;
        outEl.textContent = '';
        downloadBtn.disabled = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        statusEl.textContent = 'Starting ...';
        saveSettings();

        if (!verses.length) {
          statusEl.textContent = 'No scripture JSON loaded yet. Click Fetch or choose a JSON file.';
          startBtn.disabled = false; stopBtn.disabled = true;
          return;
        }

        const vols = parseList(volumesEl.value);
        const books = parseList(booksEl.value);
        const filtered = filterVerses(verses, vols, books);
        if (!filtered.length) {
          statusEl.textContent = 'Filter removed everything.';
          startBtn.disabled = false; stopBtn.disabled = true;
          return;
        }

        const startIdx = parseInt(startIndexEl.value || '0', 10) || 0;
        const endIdxRaw = endIndexEl.value?.trim();
        const endIdx = endIdxRaw ? parseInt(endIdxRaw, 10) : filtered.length;

        const ctxPairs = Math.max(0, parseInt(ctxPairsEl.value || '0', 10) || 0);
        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!apiBase) throw new Error('API base required.');
        if (!model) throw new Error('Model required.');

        let history = [];
        let outputLines = [];

        const total = Math.min(endIdx, filtered.length);
        for (let i = startIdx; i < total; i++) {
          if (abort) break;
          const it = filtered[i];
          const book = String(it.book_title);
          const chapter = Number(it.chapter_number);
          const verse = Number(it.verse_number);
          const text = String(it.scripture_text);
          const ref = it.verse_title ? String(it.verse_title).trim() : refString(book, chapter, verse);

          const expectedPrefix = `[${ref}]`;
          const userPrompt = makeUserPrompt(book, chapter, verse, text);

          statusEl.textContent = `Processing ${i + 1} / ${total} ... ${ref}`;
          let raw = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });

          let line = postprocessLine(raw, expectedPrefix);
          if (!bodyOk(line, expectedPrefix)) {
            const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line2 = postprocessLine(raw2, expectedPrefix);
            if (bodyOk(line2, expectedPrefix)) line = line2;
          }

          const recentAssistant = history.filter(m => m.role === 'assistant').map(m => m.content);
          const recentStarts = new Set(recentAssistant.map(ln => openingNgram((ln.split(']', 1)[1] || ''))));
          const thisStart = openingNgram((line.split(']', 1)[1] || ''));
          if (ctxPairs > 0 && recentStarts.has(thisStart)) {
            const raw3 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(1.0, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line3 = postprocessLine(raw3, expectedPrefix);
            if (bodyOk(line3, expectedPrefix)) line = line3;
          }

          outputLines.push(line);
          outEl.textContent += line + '\n';

          history.push({ role: 'user', content: `Reference: ${ref}\nText: "${normalizeAscii(text)}"` });
          history.push({ role: 'assistant', content: line });

          // maintain recent context length
          if (history.length > ctxPairs * 2) history.splice(0, history.length - ctxPairs * 2);

          await new Promise(r => setTimeout(r, 40));
        }

        statusEl.textContent = abort ? 'Stopped.' : 'Done.';
        if (outputLines.length) {
          downloadBtn.disabled = false;
          downloadBtn.onclick = () => {
            const blob = new Blob([outputLines.join('\n') + '\n'], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'styled_bible.txt';
            a.click();
            URL.revokeObjectURL(a.href);
          };
        }
      } catch (e) {
        statusEl.textContent = `Error ... ${e.message}`;
      } finally {
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    });

    stopBtn.addEventListener('pointerup', () => { abort = true; });

    // ---------- output copy/share actions
    if (copyOutBtn) {
      copyOutBtn.addEventListener('pointerup', async () => {
        const txt = (outEl.textContent || '').trim();
        if (!txt) { setOutStatus('Nothing to copy'); return; }
        const ok = await copyToClipboard(txt);
        setOutStatus(ok ? 'Copied to clipboard' : 'Copy failed');
      });
    }
    if (shareOutBtn) {
      // Disable if text share is unsupported
      if (!('share' in navigator)) {
        shareOutBtn.disabled = true;
        shareOutBtn.title = 'Web Share API (text) not supported';
      }
      shareOutBtn.addEventListener('pointerup', shareOutput);
    }

    // ---------- single verse run
    runSingleBtn.addEventListener('pointerup', async () => {
      try {
        singleStatus.textContent = 'Running...';
        // Clear output so single-verse result starts fresh
        outEl.textContent = '';
        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!verses.length) throw new Error('Load JSON first');
        if (!apiBase) throw new Error('API base required');
        if (!model) throw new Error('Model required');

        const book = bookSel.value;
        const chapter = Number(chapterSel.value);
        const verseNo = Number(verseSel.value);
        const fallback = verses.find(v => v.book_title === book && Number(v.chapter_number) === chapter && Number(v.verse_number) === verseNo)?.scripture_text || '';
        const srcText = singleTextEl.value.trim() || fallback;

        const userPrompt = makeUserPrompt(book, chapter, verseNo, srcText);
        const expectedPrefix = `[${refString(book, chapter, verseNo)}]`;

        const raw = await chatOnce({
          apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value)
        });

        let line = postprocessLine(raw, expectedPrefix);
        if (!bodyOk(line, expectedPrefix)) {
          const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
          const line2 = postprocessLine(raw2, expectedPrefix);
          if (bodyOk(line2, expectedPrefix)) line = line2;
        }

        // Replace output with just this single result
        outEl.textContent = line + '\n';
        singleStatus.textContent = 'Done.';
      } catch (e) {
        singleStatus.textContent = `Error ... ${e.message}`;
      }
    });

    // ---------- single chapter run
    runChapterBtn.addEventListener('pointerup', async () => {
      try {
        singleStatus.textContent = 'Running chapter...';
        outEl.textContent = '';

        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!verses.length) throw new Error('Load JSON first');
        if (!apiBase) throw new Error('API base required');
        if (!model) throw new Error('Model required');

        const book = bookSel.value;
        const chapter = Number(chapterSel.value);

        const rows = verses
          .filter(v => v.book_title === book && Number(v.chapter_number) === chapter)
          .sort((a,b) => Number(a.verse_number) - Number(b.verse_number));
        if (!rows.length) throw new Error('No verses for this chapter');

        const ctxPairs = Math.max(0, parseInt(ctxPairsEl.value || '0', 10) || 0);
        let history = [];

        for (let i = 0; i < rows.length; i++) {
          const it = rows[i];
          const verseNo = Number(it.verse_number);
          const text = String(it.scripture_text || '');
          const ref = it.verse_title ? String(it.verse_title).trim() : refString(book, chapter, verseNo);

          singleStatus.textContent = `Processing ${i + 1} / ${rows.length} ... ${ref}`;

          const userPrompt = makeUserPrompt(book, chapter, verseNo, text);
          const expectedPrefix = `[${ref}]`;

          let raw = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
          let line = postprocessLine(raw, expectedPrefix);

          if (!bodyOk(line, expectedPrefix)) {
            const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line2 = postprocessLine(raw2, expectedPrefix);
            if (bodyOk(line2, expectedPrefix)) line = line2;
          }

          // repetition guard using recent assistant n-grams
          const recentAssistant = history.filter(m => m.role === 'assistant').map(m => m.content);
          const recentStarts = new Set(recentAssistant.map(ln => openingNgram((ln.split(']', 1)[1] || ''))));
          const thisStart = openingNgram((line.split(']', 1)[1] || ''));
          if (ctxPairs > 0 && recentStarts.has(thisStart)) {
            const raw3 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(1.0, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line3 = postprocessLine(raw3, expectedPrefix);
            if (bodyOk(line3, expectedPrefix)) line = line3;
          }

          outEl.textContent += line + '\n';

          history.push({ role: 'user', content: `Reference: ${ref}\nText: "${normalizeAscii(text)}"` });
          history.push({ role: 'assistant', content: line });
          if (history.length > ctxPairs * 2) history.splice(0, history.length - ctxPairs * 2);

          await new Promise(r => setTimeout(r, 40));
        }

        singleStatus.textContent = 'Done.';
      } catch (e) {
        singleStatus.textContent = `Error ... ${e.message}`;
      }
    });

    // initial UI wiring
    function initModelSelectUI() {
      if (!modelSelectEl.options.length) {
        // minimal starter list so selector is usable on first load, esp. mobile
        ['gpt-4.1-mini','gpt-4.1-nano','qwen3-4b-instruct-2507','gpt-4o-mini','gpt-4o','llama-3.1-8b-instruct','mistral-small-latest']
          .forEach(id => {
            const opt = document.createElement('option');
            opt.value = id; opt.textContent = id;
            modelSelectEl.appendChild(opt);
          });
      }
      // restore selection if saved
      const saved = (() => {
        try { return (JSON.parse(localStorage.getItem(SETTINGS_KEY))||{}).modelSelect || ''; } catch { return ''; }
      })();
      if (saved) {
        const found = Array.from(modelSelectEl.options).some(o => o.value === saved);
        modelSelectEl.value = found ? saved : modelSelectEl.options[0].value;
      }
    }
    initModelSelectUI();

    // custom model toggle visibility correction on load
    updateModelInputsVisibility();

    // Auto fetch last JSON on first load if enabled
    (async () => {
      try {
        const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
        if (s && s.autoFetchJson === 'true' && (jsonUrlEl.value || '').trim()) {
          await loadJsonFromUrl();
        }
      } catch {}
    })();
  </script>
</body>
</html>
