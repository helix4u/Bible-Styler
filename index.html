<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Bible Styler ... browser edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no">
  <style>
    :root {
      --bg: #0b0f14;
      --bg-elev: #0f172a;
      --bg-input: #0b1220;
      --border: #1e293b;
      --border-strong: #334155;
      --text: #e5e7eb;
      --text-muted: #94a3b8;
      --accent: #38bdf8;
      --accent-2: #22d3ee;
      --danger: #f43f5e;
      --ok: #34d399;
      --term: #a7f3d0;
      --term-bg: #071019;
      --focus: 0 0 0 3px rgba(56, 189, 248, 0.35);
      --radius: 12px;
      --font-mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --font-sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    html, body {
      background: var(--bg);
      color: var(--text);
      margin: 0; padding: 0;
      font-family: var(--font-sans);
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    body {
      padding: 24px;
      padding-left: max(16px, env(safe-area-inset-left));
      padding-right: max(16px, env(safe-area-inset-right));
      padding-bottom: max(16px, env(safe-area-inset-bottom));
    }
    h1 { margin: 0 0 12px 0; font-size: 20px; letter-spacing: 0.2px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .row { grid-column: 1 / -1; }
    .card { border: 1px solid var(--border); border-radius: var(--radius); padding: 14px; background: var(--bg-elev); box-shadow: 0 1px 0 rgba(255,255,255,0.02) inset, 0 0 0 1px rgba(255,255,255,0.02); }
    .grid > * { min-width: 0; }
    label { font-size: 12px; display: block; margin-bottom: 6px; color: var(--text-muted); }
    input, textarea, select, button { font: inherit; color: inherit; }
    input, textarea, select {
      width: 100%; box-sizing: border-box; padding: 12px 14px;
      border: 1px solid var(--border-strong); border-radius: 10px; background: var(--bg-input);
      color: var(--text); outline: none; transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
      font-size: 16px; line-height: 1.2;  /* avoid iOS zoom */
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    input::placeholder, textarea::placeholder { color: #6b7280; }
    input:focus, textarea:focus, select:focus { border-color: var(--accent); box-shadow: var(--focus); }
    textarea { min-height: 120px; resize: vertical; }
    .mono { font-family: var(--font-mono); }
    .btn {
      padding: 12px 16px; border: 1px solid var(--accent-2); border-radius: 10px;
      background: linear-gradient(180deg, var(--accent) 0%, var(--accent-2) 100%);
      color: #001018; cursor: pointer; font-weight: 600; transition: filter 120ms ease, transform 60ms ease; user-select: none;
      min-height: 44px; /* touch target */
      font-size: 16px;
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { background: transparent; color: var(--text); border-color: var(--border-strong); }
    .btn.danger { border-color: var(--danger); background: linear-gradient(180deg, #fb7185 0%, var(--danger) 100%); color: #1b0310; }
    .btn.ok { border-color: var(--ok); background: linear-gradient(180deg, #6ee7b7 0%, var(--ok) 100%); color: #032018; }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }
    .inline { display: inline-flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .muted { color: var(--text-muted); font-size: 12px; }
    .out { white-space: pre-wrap; font-family: var(--font-mono); background: var(--term-bg); color: var(--term); padding: 14px; border-radius: 10px; min-height: 180px; border: 1px solid var(--border-strong); }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #0b2a33; color: #7dd3fc; border: 1px solid #0a3b48; font-size: 11px; font-weight: 600; }
    .tabs { display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
    .tab { padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border-strong); cursor: pointer; user-select: none; background: #0b1220; min-height: 40px; display: inline-flex; align-items: center; }
    .tab.active { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.35); }
    @media (max-width: 920px) {
      body { padding: 16px; }
      .grid { grid-template-columns: repeat(6, 1fr); gap: 10px; }
    }
    @media (max-width: 640px) {
      .grid { grid-template-columns: repeat(4, 1fr); gap: 8px; }
      /* Force grid items to stack to avoid overlaps from inline grid-column spans */
      .grid > * { grid-column: 1 / -1 !important; }
      .inline { gap: 6px; }
      label { margin-bottom: 4px; }
      input, textarea, select { font-size: 16px; }
      .btn { width: 100%; justify-content: center; }
    }
  </style>
</head>
<body>
  <h1>Bible Styler ... browser edition <span class="badge">dark</span></h1>
  <div class="muted" style="margin: 6px 0 12px 0;">
    If this helps you, consider supporting:
    <a href="https://ko-fi.com/gille" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: none;">ko-fi.com/gille</a>
  </div>

  <div class="grid">
    <!-- provider presets and api config -->
    <div class="row card">
      <div class="grid">
        <div style="grid-column: span 4;">
          <label for="vendor">Vendor preset</label>
          <select id="vendor">
            <option>Custom</option>
            <option>LM Studio ... local</option>
            <option>Ollama ... OpenAI compat</option>
            <option>OpenAI</option>
            <option>OpenRouter</option>
            <option>Together</option>
            <option>Groq</option>
            <option>Fireworks</option>
            <option>DeepInfra</option>
            <option>Cerebras</option>
          </select>
        </div>
        <div style="grid-column: span 5;">
          <label for="apiBase">API base ... OpenAI compatible chat completions</label>
          <input id="apiBase" placeholder="Example: http://127.0.0.1:1234/v1/chat/completions" spellcheck="false" autocomplete="off">
        </div>
        <div style="grid-column: span 3;">
          <label>Fetch models</label>
          <div class="inline">
            <button id="fetchModels" class="btn secondary">Fetch</button>
            <span id="modelsStatus" class="muted" aria-live="polite"></span>
          </div>
        </div>

        <div style="grid-column: span 6;">
          <label for="apiKey">API key ... stored only in this browser</label>
          <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off">
        </div>

        <!-- model selector with mobile-safe select and an optional free-typing input -->
        <div style="grid-column: span 3;">
          <label for="modelSelect">Model</label>
          <select id="modelSelect"></select>
          <input id="modelText" style="display:none; margin-top:8px;" placeholder="type a model id..." spellcheck="false" autocomplete="off">
          <div class="inline" style="margin-top:6px;">
            <input id="customModelToggle" type="checkbox" style="width:auto;">
            <label for="customModelToggle" style="margin:0;">type custom</label>
          </div>
        </div>

        <div style="grid-column: span 3;">
          <label for="temperature">Temperature</label>
          <input id="temperature" type="number" step="0.1" min="0" max="2" value="0.9">
        </div>

        <div style="grid-column: span 3;">
          <label for="stream">Stream tokens</label>
          <select id="stream">
            <option value="true" selected>true</option>
            <option value="false">false</option>
          </select>
        </div>
        <div style="grid-column: span 9;">
          <label for="extraHeaders">Extra headers ... JSON object ... optional</label>
          <textarea id="extraHeaders" class="mono" placeholder='{"HTTP-Referer":"https://your.site","X-Title":"Bible Styler"}'></textarea>
        </div>

        <div style="grid-column: span 12;">
          <label for="systemPrompt">Style system prompt</label>
          <textarea id="systemPrompt" class="mono"></textarea>
        </div>

        <!-- personas: presets + save slots -->
        <div style="grid-column: span 12;">
          <div class="grid">
            <div style="grid-column: span 6;">
              <label for="presetSelect">Built-in presets</label>
              <div class="inline">
                <select id="presetSelect">
                  <option value="stoner">Stoner (default)</option>
                  <option value="zoomer">Zoomer</option>
                  <option value="houseish">Cynical TV Doctor (House-ish)</option>
                </select>
                <button id="applyPreset" class="btn secondary">Apply preset</button>
              </div>
            </div>
            <div style="grid-column: span 6;">
              <label>Saved persona slots (local to this browser)</label>
              <div class="inline">
                <select id="slotSelect"></select>
                <button id="saveSlot" class="btn">Save to slot</button>
                <button id="loadSlot" class="btn secondary">Load slot</button>
                <button id="renameSlot" class="btn secondary">Rename</button>
                <button id="clearSlot" class="btn danger">Clear</button>
              </div>
            </div>
          </div>
        </div>

        <div style="grid-column: span 12;">
          <label for="stops">Stops ... comma separated</label>
          <input id="stops" value="Reference:,AI:,---">
        </div>
		<div class="row card" id="httpsWarn" style="display:none;">
		Heads up ... this page is HTTPS. Calls to http://localhost are often blocked by browsers. Prefer an HTTPS API endpoint or test the page locally over http.
		</div>
      </div>
      <div class="muted">Do not commit keys. This page saves to localStorage on this device only.</div>
    </div>

    <!-- data source -->
    <div class="row card">
      <div class="grid">
        <div style="grid-column: span 8;">
          <label for="jsonUrl">Scripture JSON URL</label>
          <input id="jsonUrl" class="mono" value="https://raw.githubusercontent.com/johngthecreator/Book_of_Mormon_Scriptures/main/standard-works.json" spellcheck="false">
        </div>
        <div style="grid-column: span 4;">
          <label>Load JSON</label>
          <div class="inline">
            <button id="loadJson" class="btn secondary">Fetch</button>
            <input id="jsonFile" type="file" accept=".json">
          </div>
        </div>
        <div style="grid-column: span 6;">
          <label for="volumes">Include volumes ... e.g. Old Testament,New Testament</label>
          <input id="volumes" value="Old Testament,New Testament">
        </div>
        <div style="grid-column: span 6;">
          <label for="books">Limit to books ... optional ... e.g. Genesis,Exodus</label>
          <input id="books" placeholder="Genesis,Exodus">
        </div>
        <div style="grid-column: span 4;">
          <label for="startIndex">Start index ... 0 based</label>
          <input id="startIndex" type="number" min="0" value="0">
        </div>
        <div style="grid-column: span 4;">
          <label for="endIndex">End before index ... optional</label>
          <input id="endIndex" type="number" min="0" placeholder="">
        </div>
        <div style="grid-column: span 4;">
          <label for="ctxPairs">Context pairs memory</label>
          <input id="ctxPairs" type="number" min="0" value="3">
        </div>
      </div>
      <div class="muted">JSON must be an array with keys ... book_title, chapter_number, verse_number, scripture_text.</div>
    </div>

    <!-- mode tabs -->
    <div class="row card">
      <div class="tabs">
        <div class="tab active" data-panel="batchPanel" tabindex="0">Batch mode</div>
        <div class="tab" data-panel="singlePanel" tabindex="0">Single verse/chapter</div>
      </div>

      <div id="batchPanel">
        <div class="inline" style="margin-bottom: 8px;">
          <button id="startBtn" class="btn">Start</button>
          <button id="stopBtn" class="btn danger" disabled>Stop</button>
          <button id="downloadBtn" class="btn secondary" disabled>Download .txt</button>
        </div>
        <div id="status" class="muted" style="margin-top:8px;" aria-live="polite"></div>
      </div>

      <div id="singlePanel" style="display:none;">
        <div class="grid" style="margin-bottom: 8px;">
          <div style="grid-column: span 4;">
            <label for="bookSel">Book</label>
            <select id="bookSel"></select>
          </div>
          <div style="grid-column: span 4;">
            <label for="chapterSel">Chapter</label>
            <select id="chapterSel"></select>
          </div>
          <div style="grid-column: span 4;">
            <label for="verseSel">Verse</label>
            <select id="verseSel"></select>
          </div>
          <div style="grid-column: span 12;">
            <label for="singleText">Text override ... optional</label>
            <textarea id="singleText" class="mono" placeholder="Leave empty to use text from JSON"></textarea>
          </div>
        </div>
        <div class="inline" style="margin-bottom: 8px;">
          <button id="runSingle" class="btn ok">Run single verse</button>
          <button id="runChapter" class="btn">Run chapter</button>
        </div>
        <div id="singleStatus" class="muted" aria-live="polite"></div>
      </div>
    </div>

    <!-- output -->
    <div class="row card">
      <label>Output</label>
      <div id="out" class="out"></div>
    </div>
  </div>

  <script>
    // ---------- helpers
    function normalizeAscii(s) {
      return String(s)
        .replace(/\u2018|\u2019/g, "'")
        .replace(/\u201C|\u201D/g, '"')
        .replace(/\u2013|\u2014/g, "...")
        .replace(/\u00A0/g, " ");
    }
    function sanitizeOneLine(s) {
      if (!s) return "";
      s = normalizeAscii(s);
      s = s.replace(/\r/g, " ").replace(/\n/g, " ").trim();
      s = s.replace(/\s*---.*$/i, "");
      s = s.replace(/^\s*(AI|Answer|Output)\s*:\s*/i, "");
      s = s.replace(/\s*Reference\s*:.*$/i, "");
      s = Array.from(s).filter(ch => ch.codePointAt(0) < 0x2500).join("");
      return s.trim();
    }
    function refString(book, chapter, verse) { return `${book} ${chapter}:${verse}`; }
    function openingNgram(s, n = 4) {
      const toks = s.trim().split(/\s+/).filter(Boolean);
      return toks.slice(0, n).join(" ").toLowerCase();
    }
    function parseJSONOrEmpty(str) {
      const t = String(str || '').trim();
      if (!t) return {};
      try { return JSON.parse(t); } catch { return {}; }
    }

    // ---------- persona presets
    const PRESET_TEXTS = {
      stoner:
`You are rewriting each Bible verse in a stoner voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Do not narrate what you are doing. Just do it.. and do it with exaggerated tone.`,
      zoomer:
`You are rewriting each Bible verse in a zoomer voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Use tight, internet-native phrasing with occasional slang and lowercasing where natural, but keep names correctly cased. No emojis. No slurs.`,
      houseish:
`You are rewriting each Bible verse in the voice of a cynical, brilliant diagnostician from a medical drama. Dry, acerbic, brutally honest, skeptical of neat moral explanations, but precise. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Inject cutting diagnostic metaphors and bleak wit, but stay faithful to facts. No emojis. No slurs.`
    };

    // ---------- vendor presets
    const vendorPresets = {
      "Custom": {},
      "LM Studio ... local": { apiBase: "http://127.0.0.1:1234/v1/chat/completions" },
      "Ollama ... OpenAI compat": { apiBase: "http://127.0.0.1:11434/v1/chat/completions" },
      "OpenAI": { apiBase: "https://api.openai.com/v1/chat/completions" },
      "OpenRouter": {
        apiBase: "https://openrouter.ai/api/v1/chat/completions",
        extraHeaders: { "HTTP-Referer": location.origin || "https://example.com", "X-Title": "Bible Styler" }
      },
      "Together": { apiBase: "https://api.together.xyz/v1/chat/completions" },
      "Groq": { apiBase: "https://api.groq.com/openai/v1/chat/completions" },
      "Fireworks": { apiBase: "https://api.fireworks.ai/inference/v1/chat/completions" },
      "DeepInfra": { apiBase: "https://api.deepinfra.com/v1/openai/chat/completions" },
      "Cerebras": { apiBase: "https://api.cerebras.ai/v1/chat/completions" }
    };

    // ---------- UI refs
    const vendorEl = document.getElementById('vendor');
    const apiBaseEl = document.getElementById('apiBase');
    const apiKeyEl = document.getElementById('apiKey');

    const modelSelectEl = document.getElementById('modelSelect');
    const modelTextEl = document.getElementById('modelText');
    const customModelToggle = document.getElementById('customModelToggle');

    const fetchModelsBtn = document.getElementById('fetchModels');
    const modelsStatus = document.getElementById('modelsStatus');

    const temperatureEl = document.getElementById('temperature');
    const streamEl = document.getElementById('stream');
    const systemPromptEl = document.getElementById('systemPrompt');
    const stopsEl = document.getElementById('stops');
    const extraHeadersEl = document.getElementById('extraHeaders');

    const presetSelect = document.getElementById('presetSelect');
    const applyPresetBtn = document.getElementById('applyPreset');
    const slotSelect = document.getElementById('slotSelect');
    const saveSlotBtn = document.getElementById('saveSlot');
    const loadSlotBtn = document.getElementById('loadSlot');
    const renameSlotBtn = document.getElementById('renameSlot');
    const clearSlotBtn = document.getElementById('clearSlot');

    const jsonUrlEl = document.getElementById('jsonUrl');
    const loadJsonBtn = document.getElementById('loadJson');
    const jsonFileEl = document.getElementById('jsonFile');
    const volumesEl = document.getElementById('volumes');
    const booksEl = document.getElementById('books');
    const startIndexEl = document.getElementById('startIndex');
    const endIndexEl = document.getElementById('endIndex');
    const ctxPairsEl = document.getElementById('ctxPairs');

    const outEl = document.getElementById('out');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusEl = document.getElementById('status');

    const tabs = document.querySelectorAll('.tab');
    const batchPanel = document.getElementById('batchPanel');
    const singlePanel = document.getElementById('singlePanel');
    const bookSel = document.getElementById('bookSel');
    const chapterSel = document.getElementById('chapterSel');
    const verseSel = document.getElementById('verseSel');
    const singleTextEl = document.getElementById('singleText');
    const runSingleBtn = document.getElementById('runSingle');
    const runChapterBtn = document.getElementById('runChapter');
    const singleStatus = document.getElementById('singleStatus');

    const httpsWarn = document.getElementById('httpsWarn');
    if (location.protocol === 'https:') httpsWarn.style.display = 'block';

    // tabs toggle...use pointerup for better mobile behavior
    tabs.forEach(t => {
      const handler = () => {
        tabs.forEach(x => x.classList.remove('active'));
        t.classList.add('active');
        const panel = t.dataset.panel;
        batchPanel.style.display = panel === 'batchPanel' ? 'block' : 'none';
        singlePanel.style.display = panel === 'singlePanel' ? 'block' : 'none';
      };
      ['pointerup','click','keyup'].forEach(ev => t.addEventListener(ev, (e) => {
        if (ev === 'keyup' && e.key !== 'Enter' && e.key !== ' ') return;
        handler();
      }, { passive: true }));
    });

    // ---------- persistence
    const SETTINGS_KEY = 'bibleStylerSettings.v2';
    const SLOTS_KEY = 'personaSlots.v1'; // 5 slots

    function getActiveModelId() {
      return customModelToggle.checked ? modelTextEl.value.trim() : modelSelectEl.value.trim();
    }

    function saveSettings() {
      const obj = {
        vendor: vendorEl.value,
        apiBase: apiBaseEl.value,
        apiKey: apiKeyEl.value,
        modelMode: customModelToggle.checked ? 'custom' : 'select',
        modelSelect: modelSelectEl.value,
        modelText: modelTextEl.value,
        temperature: temperatureEl.value,
        stream: streamEl.value,
        systemPrompt: systemPromptEl.value,
        stops: stopsEl.value,
        jsonUrl: jsonUrlEl.value,
        volumes: volumesEl.value,
        books: booksEl.value,
        ctxPairs: ctxPairsEl.value,
        extraHeaders: extraHeadersEl.value
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj));
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (raw) {
          const s = JSON.parse(raw);
          vendorEl.value = s.vendor || 'Custom';
          apiBaseEl.value = s.apiBase || '';
          apiKeyEl.value = s.apiKey || '';
          temperatureEl.value = s.temperature || '0.9';
          streamEl.value = s.stream || 'true';
          systemPromptEl.value = s.systemPrompt || PRESET_TEXTS.stoner; // default
          stopsEl.value = s.stops || 'Reference:,AI:,---';
          jsonUrlEl.value = s.jsonUrl || jsonUrlEl.value;
          volumesEl.value = s.volumes || 'Old Testament,New Testament';
          booksEl.value = s.books || '';
          ctxPairsEl.value = s.ctxPairs || '3';
          extraHeadersEl.value = s.extraHeaders || '';
          // model mode
          const mode = s.modelMode || 'select';
          customModelToggle.checked = mode === 'custom';
          modelTextEl.value = s.modelText || '';
          modelSelectEl.value = s.modelSelect || '';
          updateModelInputsVisibility();
        } else {
          systemPromptEl.value = PRESET_TEXTS.stoner; // first load default
        }
      } catch {
        systemPromptEl.value = PRESET_TEXTS.stoner;
      }
    }

    function updateModelInputsVisibility() {
      if (customModelToggle.checked) {
        modelTextEl.style.display = 'block';
        modelSelectEl.style.display = 'none';
      } else {
        modelTextEl.style.display = 'none';
        modelSelectEl.style.display = 'block';
      }
    }

    // persist most fields
    document.querySelectorAll('input,textarea,select').forEach(el => {
      el.addEventListener('change', saveSettings, { passive: true });
      el.addEventListener('input', saveSettings, { passive: true }); // save while typing to retain on refresh
    });
    loadSettings();

    // ---------- persona slots
    function loadSlots() {
      try {
        const raw = localStorage.getItem(SLOTS_KEY);
        if (!raw) return Array.from({length:5}, () => ({name:'', prompt:''}));
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr) || arr.length !== 5) return Array.from({length:5}, () => ({name:'', prompt:''}));
        return arr.map(x => ({ name: String(x.name||''), prompt: String(x.prompt||'') }));
      } catch {
        return Array.from({length:5}, () => ({name:'', prompt:''}));
      }
    }
    function saveSlots(slots) { localStorage.setItem(SLOTS_KEY, JSON.stringify(slots)); }
    function updateSlotUI(slots) {
      slotSelect.innerHTML = '';
      slots.forEach((s, i) => {
        const label = s.name ? `Slot ${i+1}: ${s.name}` : `Slot ${i+1}: (empty)`;
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = label;
        slotSelect.appendChild(opt);
      });
      if (slotSelect.options.length) slotSelect.value = slotSelect.options[0].value;
    }

    let personaSlots = loadSlots();
    updateSlotUI(personaSlots);

    applyPresetBtn.addEventListener('pointerup', () => {
      const key = presetSelect.value;
      systemPromptEl.value = PRESET_TEXTS[key] || PRESET_TEXTS.stoner;
      saveSettings();
    });

    saveSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const current = personaSlots[idx] || {name:'', prompt:''};
      const suggested = current.name || (systemPromptEl.value.split('\n')[0].slice(0,48));
      const name = window.prompt('Name for this slot:', suggested) || suggested || `Persona ${idx+1}`;
      personaSlots[idx] = { name, prompt: systemPromptEl.value };
      saveSlots(personaSlots);
      updateSlotUI(personaSlots);
    });

    loadSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const slot = personaSlots[idx];
      if (!slot || !slot.prompt) { alert('Empty slot.'); return; }
      systemPromptEl.value = slot.prompt;
      saveSettings();
    });

    renameSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const slot = personaSlots[idx];
      if (!slot) return;
      const name = window.prompt('New name:', slot.name || `Persona ${idx+1}`);
      if (name != null) {
        personaSlots[idx].name = name.trim();
        saveSlots(personaSlots);
        updateSlotUI(personaSlots);
      }
    });

    clearSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      personaSlots[idx] = {name:'', prompt:''};
      saveSlots(personaSlots);
      updateSlotUI(personaSlots);
    });

    // ---------- apply vendor preset
    vendorEl.addEventListener('change', () => {
      const p = vendorPresets[vendorEl.value] || {};
      if (p.apiBase) apiBaseEl.value = p.apiBase;
      if (p.extraHeaders) {
        try {
          const existing = parseJSONOrEmpty(extraHeadersEl.value);
          const merged = Object.assign({}, existing, p.extraHeaders);
          extraHeadersEl.value = JSON.stringify(merged);
        } catch {
          extraHeadersEl.value = JSON.stringify(p.extraHeaders);
        }
      }
      saveSettings();
      modelsStatus.textContent = 'Preset applied';
    }, { passive: true });

    // ---------- Scripture data and selectors
    let verses = [];
    function norm(s) { return String(s || '').trim().toLowerCase(); }
    function parseList(s) {
      if (!s) return null;
      const parts = String(s).split(',').map(t => t.trim()).filter(Boolean);
      return parts.length ? parts : null;
    }
    function filterVerses(rows, volumes, books) {
      const volSet = volumes ? new Set(volumes.map(v => norm(v))) : null;
      const bookSet = books ? new Set(books.map(b => norm(b))) : null;
      const out = [];
      for (const it of rows) {
        const vol = norm(it.volume_title);
        const book = norm(it.book_title);
        if (volSet && !volSet.has(vol)) continue;
        if (bookSet && !bookSet.has(book)) continue;
        out.push(it);
      }
      return out;
    }
    async function fetchJson(url) {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }
    function populateSelectorsFromData(rows) {
      const books = Array.from(new Set(rows.map(r => r.book_title)));
      bookSel.innerHTML = books.map(b => `<option value="${b}">${b}</option>`).join('');
      if (books.length) { bookSel.value = books[0]; populateChapters(); }
    }
    function populateChapters() {
      const b = bookSel.value;
      const chapters = Array.from(new Set(verses.filter(v => v.book_title === b).map(v => Number(v.chapter_number)))).sort((a,b)=>a-b);
      chapterSel.innerHTML = chapters.map(c => `<option value="${c}">${c}</option>`).join('');
      if (chapters.length) { chapterSel.value = chapters[0]; populateVerses(); }
    }
    function populateVerses() {
      const b = bookSel.value;
      const c = Number(chapterSel.value);
      const vs = verses
        .filter(v => v.book_title === b && Number(v.chapter_number) === c)
        .map(v => Number(v.verse_number))
        .sort((a,b)=>a-b);
      const prev = Number(verseSel.value);
      verseSel.innerHTML = vs.map(v => `<option value="${v}">${v}</option>`).join('');
      if (vs.includes(prev)) {
        verseSel.value = String(prev);
      } else if (vs.length) {
        verseSel.value = String(vs[0]);
      }
      updateSinglePlaceholder();
    }

    function updateSinglePlaceholder() {
      const b = bookSel.value;
      const c = Number(chapterSel.value);
      const vno = Number(verseSel.value);
      const txt = verses.find(v => v.book_title === b && Number(v.chapter_number) === c && Number(v.verse_number) === vno)?.scripture_text || '';
      // Show full original scripture text for mobile usability; do not truncate
      singleTextEl.placeholder = txt ? `JSON text: ${txt}` : 'No JSON text found';
    }

    function bindMobileSelect(sel, handler) {
      ['change','input','pointerup','click','blur'].forEach(ev => sel.addEventListener(ev, handler, { passive: true }));
    }

    document.getElementById('loadJson').addEventListener('pointerup', async () => {
      try {
        statusEl.textContent = 'Fetching JSON...';
        const data = await fetchJson(jsonUrlEl.value);
        if (!Array.isArray(data) || !data.length) throw new Error('Expected JSON array');
        verses = data;
        statusEl.textContent = `Loaded ${data.length} rows`;
        populateSelectorsFromData(verses);
      } catch (e) {
        statusEl.textContent = `Failed to load JSON ... ${e.message}`;
      }
    });

    jsonFileEl.addEventListener('change', async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        if (!Array.isArray(data) || !data.length) throw new Error('Expected JSON array');
        verses = data;
        statusEl.textContent = `Loaded ${data.length} rows from file`;
        populateSelectorsFromData(verses);
      } catch (e) {
        statusEl.textContent = `Bad JSON file ... ${e.message}`;
      }
    });

    bindMobileSelect(bookSel, populateChapters);
    bindMobileSelect(chapterSel, populateVerses);
    bindMobileSelect(verseSel, updateSinglePlaceholder);

    // ---------- chat call (SSE or JSON)
    async function chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders }) {
      const headers = { 'Content-Type': 'application/json' };
      if (apiKey) {
        headers['Authorization'] = `Bearer ${apiKey}`;
        headers['X-API-Key'] = apiKey;
      }
      if (extraHeaders) Object.assign(headers, extraHeaders);

      const payload = {
        model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature,
        stream
      };
      if (stops && stops.length) payload.stop = stops;

      const resp = await fetch(apiBase, { method: 'POST', headers, body: JSON.stringify(payload) });
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`HTTP ${resp.status} ... ${txt.slice(0, 400)}`);
      }

      const ct = resp.headers.get('content-type') || '';
      if (!stream || ct.includes('application/json')) {
        const obj = await resp.json();
        return obj?.choices?.[0]?.message?.content?.trim() || '';
      }

      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buf = '';
      let out = '';
      for (;;) {
        const { value, done } = await reader.read();
        if (done) break;
        buf += decoder.decode(value, { stream: true });
        const parts = buf.split('\n\n');
        buf = parts.pop() || '';
        for (const chunk of parts) {
          const line = chunk.trim();
          if (!line) continue;
          const raw = line.startsWith('data: ') ? line.slice(6).trim() : line;
          if (raw === '[DONE]') { reader.cancel().catch(()=>{}); break; }
          try {
            const obj = JSON.parse(raw);
            const ch0 = obj.choices?.[0] || {};
            const piece = ch0.delta?.content ?? ch0.message?.content ?? '';
            if (piece) out += piece;
          } catch {}
        }
      }
      return out.trim();
    }

    function makeUserPrompt(book, chapter, verse, text) {
      return `Reference: ${book} ${chapter}:${verse}\nText: "${normalizeAscii(text)}"`;
    }
    function postprocessLine(result, expectedPrefix) {
      if (!result) return expectedPrefix;
      const safe = expectedPrefix.slice(1, -1).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const rx = new RegExp('\\[' + safe + '\\][^\\n\\r]*');
      const m = result.match(rx);
      let s = m ? m[0] : result;
      s = sanitizeOneLine(s);
      if (!s.startsWith(expectedPrefix)) {
        const body = s.replace(/^[\[\("]+/, '').trim();
        s = `${expectedPrefix} ${body}`;
      }
      return s;
    }
    function bodyOk(line, expectedPrefix, minChars = 6) {
      const body = line.slice(expectedPrefix.length).trim();
      return body.length >= minChars;
    }

    // ---------- fetch models (robust)
    async function fetchModelsList() {
      const apiBase = apiBaseEl.value.trim();
      const key = apiKeyEl.value.trim();
      if (!apiBase) throw new Error('API base required');

      const headers = { 'Accept': 'application/json' };
      if (key) headers['Authorization'] = `Bearer ${key}`;
      try { Object.assign(headers, parseJSONOrEmpty(extraHeadersEl.value)); } catch {}

      const baseRoot = apiBase
        .replace(/\/chat\/completions$/i, '')
        .replace(/\/+$/, '');
      const hasV1 = /\/v1$/i.test(baseRoot);

      const candidates = [
        `${baseRoot}/models`,
        hasV1 ? null : `${baseRoot}/v1/models`
      ].filter(Boolean);

      const isOllama = /localhost:11434|127\.0\.0\.1:11434/.test(apiBase);
      if (isOllama) candidates.push(apiBase.replace(/\/v1\/chat\/completions$/,'') + '/api/tags');

      let lastErr = 'no models endpoint responded';
      for (const url of candidates) {
        try {
          const r = await fetch(url, { headers });
          if (!r.ok) { lastErr = `HTTP ${r.status} at ${url}`; continue; }
          const data = await r.json();
          if (data && Array.isArray(data.data)) {
            return data.data.map(m => m.id || m.name).filter(Boolean);
          } else if (data && Array.isArray(data.models)) {
            return data.models.map(m => m.id || m.name).filter(Boolean);
          }
        } catch (e) { lastErr = e.message || String(e); }
      }
      throw new Error(lastErr);
    }

    fetchModelsBtn.addEventListener('pointerup', async () => {
      modelsStatus.textContent = 'Loading models...';
      // Remember selections before refresh
      const savedSelect = (() => { try { return (JSON.parse(localStorage.getItem(SETTINGS_KEY))||{}).modelSelect || ''; } catch { return ''; } })();
      const prevSelect = modelSelectEl.value;
      modelSelectEl.innerHTML = '';
      try {
        const ids = await fetchModelsList();
        if (!ids.length) throw new Error('no models returned');
        ids.forEach(id => {
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = id;
          modelSelectEl.appendChild(opt);
        });
        // Keep saved or previous selection if still present, otherwise pick first
        let chosen = '';
        if (savedSelect && ids.includes(savedSelect)) chosen = savedSelect;
        else if (prevSelect && ids.includes(prevSelect)) chosen = prevSelect;
        else if (ids.length) chosen = ids[0];
        if (chosen) modelSelectEl.value = chosen;
        modelsStatus.textContent = `Loaded ${ids.length}`;
        saveSettings();
      } catch (e) {
        modelsStatus.textContent = `Failed ... ${e.message}`;
      }
    });

    // toggle custom model typing
    customModelToggle.addEventListener('change', () => {
      updateModelInputsVisibility();
      saveSettings();
    }, { passive: true });

    // ---------- batch run
    let abort = false;
    startBtn.addEventListener('pointerup', async () => {
      try {
        abort = false;
        outEl.textContent = '';
        downloadBtn.disabled = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        statusEl.textContent = 'Starting ...';
        saveSettings();

        if (!verses.length) {
          statusEl.textContent = 'No scripture JSON loaded yet. Click Fetch or choose a JSON file.';
          startBtn.disabled = false; stopBtn.disabled = true;
          return;
        }

        const vols = parseList(volumesEl.value);
        const books = parseList(booksEl.value);
        const filtered = filterVerses(verses, vols, books);
        if (!filtered.length) {
          statusEl.textContent = 'Filter removed everything.';
          startBtn.disabled = false; stopBtn.disabled = true;
          return;
        }

        const startIdx = parseInt(startIndexEl.value || '0', 10) || 0;
        const endIdxRaw = endIndexEl.value?.trim();
        const endIdx = endIdxRaw ? parseInt(endIdxRaw, 10) : filtered.length;

        const ctxPairs = Math.max(0, parseInt(ctxPairsEl.value || '0', 10) || 0);
        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!apiBase) throw new Error('API base required.');
        if (!model) throw new Error('Model required.');

        let history = [];
        let outputLines = [];

        const total = Math.min(endIdx, filtered.length);
        for (let i = startIdx; i < total; i++) {
          if (abort) break;
          const it = filtered[i];
          const book = String(it.book_title);
          const chapter = Number(it.chapter_number);
          const verse = Number(it.verse_number);
          const text = String(it.scripture_text);
          const ref = it.verse_title ? String(it.verse_title).trim() : refString(book, chapter, verse);

          const expectedPrefix = `[${ref}]`;
          const userPrompt = makeUserPrompt(book, chapter, verse, text);

          statusEl.textContent = `Processing ${i + 1} / ${total} ... ${ref}`;
          let raw = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });

          let line = postprocessLine(raw, expectedPrefix);
          if (!bodyOk(line, expectedPrefix)) {
            const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line2 = postprocessLine(raw2, expectedPrefix);
            if (bodyOk(line2, expectedPrefix)) line = line2;
          }

          const recentAssistant = history.filter(m => m.role === 'assistant').map(m => m.content);
          const recentStarts = new Set(recentAssistant.map(ln => openingNgram((ln.split(']', 1)[1] || ''))));
          const thisStart = openingNgram((line.split(']', 1)[1] || ''));
          if (ctxPairs > 0 && recentStarts.has(thisStart)) {
            const raw3 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(1.0, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line3 = postprocessLine(raw3, expectedPrefix);
            if (bodyOk(line3, expectedPrefix)) line = line3;
          }

          outputLines.push(line);
          outEl.textContent += line + '\n';

          history.push({ role: 'user', content: `Reference: ${ref}\nText: "${normalizeAscii(text)}"` });
          history.push({ role: 'assistant', content: line });

          // maintain recent context length
          if (history.length > ctxPairs * 2) history.splice(0, history.length - ctxPairs * 2);

          await new Promise(r => setTimeout(r, 40));
        }

        statusEl.textContent = abort ? 'Stopped.' : 'Done.';
        if (outputLines.length) {
          downloadBtn.disabled = false;
          downloadBtn.onclick = () => {
            const blob = new Blob([outputLines.join('\n') + '\n'], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'styled_bible.txt';
            a.click();
            URL.revokeObjectURL(a.href);
          };
        }
      } catch (e) {
        statusEl.textContent = `Error ... ${e.message}`;
      } finally {
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    });

    stopBtn.addEventListener('pointerup', () => { abort = true; });

    // ---------- single verse run
    runSingleBtn.addEventListener('pointerup', async () => {
      try {
        singleStatus.textContent = 'Running...';
        // Clear output so single-verse result starts fresh
        outEl.textContent = '';
        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!verses.length) throw new Error('Load JSON first');
        if (!apiBase) throw new Error('API base required');
        if (!model) throw new Error('Model required');

        const book = bookSel.value;
        const chapter = Number(chapterSel.value);
        const verseNo = Number(verseSel.value);
        const fallback = verses.find(v => v.book_title === book && Number(v.chapter_number) === chapter && Number(v.verse_number) === verseNo)?.scripture_text || '';
        const srcText = singleTextEl.value.trim() || fallback;

        const userPrompt = makeUserPrompt(book, chapter, verseNo, srcText);
        const expectedPrefix = `[${refString(book, chapter, verseNo)}]`;

        const raw = await chatOnce({
          apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value)
        });

        let line = postprocessLine(raw, expectedPrefix);
        if (!bodyOk(line, expectedPrefix)) {
          const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
          const line2 = postprocessLine(raw2, expectedPrefix);
          if (bodyOk(line2, expectedPrefix)) line = line2;
        }

        // Replace output with just this single result
        outEl.textContent = line + '\n';
        singleStatus.textContent = 'Done.';
      } catch (e) {
        singleStatus.textContent = `Error ... ${e.message}`;
      }
    });

    // ---------- single chapter run
    runChapterBtn.addEventListener('pointerup', async () => {
      try {
        singleStatus.textContent = 'Running chapter...';
        outEl.textContent = '';

        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!verses.length) throw new Error('Load JSON first');
        if (!apiBase) throw new Error('API base required');
        if (!model) throw new Error('Model required');

        const book = bookSel.value;
        const chapter = Number(chapterSel.value);

        const rows = verses
          .filter(v => v.book_title === book && Number(v.chapter_number) === chapter)
          .sort((a,b) => Number(a.verse_number) - Number(b.verse_number));
        if (!rows.length) throw new Error('No verses for this chapter');

        const ctxPairs = Math.max(0, parseInt(ctxPairsEl.value || '0', 10) || 0);
        let history = [];

        for (let i = 0; i < rows.length; i++) {
          const it = rows[i];
          const verseNo = Number(it.verse_number);
          const text = String(it.scripture_text || '');
          const ref = it.verse_title ? String(it.verse_title).trim() : refString(book, chapter, verseNo);

          singleStatus.textContent = `Processing ${i + 1} / ${rows.length} ... ${ref}`;

          const userPrompt = makeUserPrompt(book, chapter, verseNo, text);
          const expectedPrefix = `[${ref}]`;

          let raw = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
          let line = postprocessLine(raw, expectedPrefix);

          if (!bodyOk(line, expectedPrefix)) {
            const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line2 = postprocessLine(raw2, expectedPrefix);
            if (bodyOk(line2, expectedPrefix)) line = line2;
          }

          // repetition guard using recent assistant n-grams
          const recentAssistant = history.filter(m => m.role === 'assistant').map(m => m.content);
          const recentStarts = new Set(recentAssistant.map(ln => openingNgram((ln.split(']', 1)[1] || ''))));
          const thisStart = openingNgram((line.split(']', 1)[1] || ''));
          if (ctxPairs > 0 && recentStarts.has(thisStart)) {
            const raw3 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(1.0, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line3 = postprocessLine(raw3, expectedPrefix);
            if (bodyOk(line3, expectedPrefix)) line = line3;
          }

          outEl.textContent += line + '\n';

          history.push({ role: 'user', content: `Reference: ${ref}\nText: "${normalizeAscii(text)}"` });
          history.push({ role: 'assistant', content: line });
          if (history.length > ctxPairs * 2) history.splice(0, history.length - ctxPairs * 2);

          await new Promise(r => setTimeout(r, 40));
        }

        singleStatus.textContent = 'Done.';
      } catch (e) {
        singleStatus.textContent = `Error ... ${e.message}`;
      }
    });

    // initial UI wiring
    function initModelSelectUI() {
      if (!modelSelectEl.options.length) {
        // minimal starter list so selector is usable on first load, esp. mobile
        ['gpt-4.1-mini','gpt-4.1-nano','qwen3-4b-instruct-2507','gpt-4o-mini','gpt-4o','llama-3.1-8b-instruct','mistral-small-latest']
          .forEach(id => {
            const opt = document.createElement('option');
            opt.value = id; opt.textContent = id;
            modelSelectEl.appendChild(opt);
          });
      }
      // restore selection if saved
      const saved = (() => {
        try { return (JSON.parse(localStorage.getItem(SETTINGS_KEY))||{}).modelSelect || ''; } catch { return ''; }
      })();
      if (saved) {
        const found = Array.from(modelSelectEl.options).some(o => o.value === saved);
        modelSelectEl.value = found ? saved : modelSelectEl.options[0].value;
      }
    }
    initModelSelectUI();

    // custom model toggle visibility correction on load
    updateModelInputsVisibility();
  </script>
</body>
</html>
