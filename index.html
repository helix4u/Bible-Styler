<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Scripture Styler ... browser edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no">
  <style>
    :root {
      --bg: #0b0f14;
      --bg-elev: #0f172a;
      --bg-input: #0b1220;
      --border: #1e293b;
      --border-strong: #334155;
      --text: #e5e7eb;
      --text-muted: #94a3b8;
      --accent: #38bdf8;
      --accent-2: #22d3ee;
      --danger: #f43f5e;
      --ok: #34d399;
      --term: #a7f3d0;
      --term-bg: #071019;
      --focus: 0 0 0 3px rgba(56, 189, 248, 0.35);
      --radius: 12px;
      --font-mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      --font-serif: "Times New Roman", Times, Georgia, "Palatino Linotype", serif;
      --font-display: "Impact", "Franklin Gothic Bold", "Trebuchet MS", sans-serif;
      --font-script: "Brush Script MT", "Lucida Handwriting", cursive;
      --font-elegant: "Garamond", "Minion Pro", "Book Antiqua", serif;
      --font-modern: "Helvetica Neue", "Inter", "SF Pro Display", sans-serif;
      --font-tech: "Courier New", "Source Code Pro", "JetBrains Mono", monospace;
      --font-rounded: "Nunito", "Quicksand", "Trebuchet MS", sans-serif;
      --font-condensed: "Roboto Condensed", "Helvetica Neue", "Arial Narrow", sans-serif;
      --font-readable: Verdana, Geneva, Tahoma, sans-serif;
      --font-slab: "Rockwell", "Roboto Slab", "Clarendon", serif;
      --font-humanist: "Gill Sans", "Segoe UI", Calibri, sans-serif;
      /* button theming defaults (dark) */
      --btn-bg: var(--accent);
      --btn-bg-2: var(--accent-2);
      --btn-fg: #001018;
      --btn-secondary-fg: var(--text);
      --btn-danger-top: #fb7185;
      --btn-danger-bg: var(--danger);
      --btn-danger-fg: #1b0310;
      --btn-ok-top: #6ee7b7;
      --btn-ok-bg: var(--ok);
      --btn-ok-fg: #032018;
      /* compact button sizing */
      --btn-py: 8px;
      --btn-px: 12px;
      --btn-font: 14px;
      --btn-min-h: 40px;
      --btn-radius: 8px;
      /* neutral button palette */
      --btn-neutral-bg: #4b5563;
      --btn-neutral-bg-2: #374151;
      --btn-neutral-fg: #f3f4f6;
      --btn-neutral-border: #6b7280;
      /* link color */
      --link: #16a34a;
    }
    html, body {
      background: var(--bg);
      color: var(--text);
      margin: 0; padding: 0;
      font-family: var(--font-sans);
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    body {
      padding: 24px;
      padding-left: max(16px, env(safe-area-inset-left));
      padding-right: max(16px, env(safe-area-inset-right));
      padding-bottom: max(16px, env(safe-area-inset-bottom));
    }
    h1 { margin: 0 0 12px 0; font-size: 20px; letter-spacing: 0.2px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .row { grid-column: 1 / -1; }
    .card { border: 1px solid var(--border); border-radius: var(--radius); padding: 14px; background: var(--bg-elev); box-shadow: 0 1px 0 rgba(255,255,255,0.02) inset, 0 0 0 1px rgba(255,255,255,0.02); }
    .grid > * { min-width: 0; }
    label { font-size: 12px; display: block; margin-bottom: 6px; color: var(--text-muted); }
    input, textarea, select, button { font: inherit; color: inherit; }
    input, textarea, select {
      width: 100%; box-sizing: border-box; padding: 12px 14px;
      border: 1px solid var(--border-strong); border-radius: 10px; background: var(--bg-input);
      color: var(--text); outline: none; transition: border-color 120ms ease, box-shadow 120ms ease, background 120ms ease;
      font-size: 16px; line-height: 1.2;  /* avoid iOS zoom */
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    input::placeholder, textarea::placeholder { color: #6b7280; }
    input:focus, textarea:focus, select:focus { border-color: var(--accent); box-shadow: var(--focus); }
    textarea { min-height: 120px; resize: vertical; }
    .mono { font-family: var(--font-mono); }
    .btn {
      padding: var(--btn-py) var(--btn-px); border: 1px solid var(--btn-bg-2); border-radius: var(--btn-radius);
      background: linear-gradient(180deg, var(--btn-bg) 0%, var(--btn-bg-2) 100%);
      color: var(--btn-fg); cursor: pointer; font-weight: 600; transition: filter 120ms ease, transform 60ms ease; user-select: none;
      min-height: var(--btn-min-h); /* touch target */
      font-size: var(--btn-font);
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { background: transparent; color: var(--btn-secondary-fg); border-color: var(--border-strong); }
    .btn.danger { border-color: var(--btn-danger-bg); background: linear-gradient(180deg, var(--btn-danger-top) 0%, var(--btn-danger-bg) 100%); color: var(--btn-danger-fg); }
    .btn.ok { border-color: var(--btn-ok-bg); background: linear-gradient(180deg, var(--btn-ok-top) 0%, var(--btn-ok-bg) 100%); color: var(--btn-ok-fg); }
    .btn.neutral { border-color: var(--btn-neutral-border); background: linear-gradient(180deg, var(--btn-neutral-bg) 0%, var(--btn-neutral-bg-2) 100%); color: var(--btn-neutral-fg); }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }
    .inline { display: inline-flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .muted { color: var(--text-muted); font-size: 12px; }
    .out { white-space: pre-wrap; font-family: var(--font-mono); background: var(--term-bg); color: var(--term); padding: 14px; border-radius: 10px; min-height: 180px; border: 1px solid var(--border-strong); }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; background: var(--bg-input); color: var(--accent); border: 1px solid var(--accent-2); font-size: 11px; font-weight: 600; }
    .tabs { display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
    .tab { padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border-strong); cursor: pointer; user-select: none; background: var(--bg-input); min-height: 40px; display: inline-flex; align-items: center; color: var(--text); }
    .tab.active { border-color: var(--accent); box-shadow: var(--focus); background: var(--bg-elev); }
    /* details-like toggle styling */
    #setupSummary button.btn.secondary { min-width: 180px; }
    /* links */
    a, a:visited { color: var(--link) !important; }
    a { text-decoration: none; }
    a:hover, a:focus { text-decoration: underline; }
    @media (max-width: 920px) {
      body { padding: 16px; }
      .grid { grid-template-columns: repeat(6, 1fr); gap: 10px; }
    }
    @media (max-width: 640px) {
      .grid { grid-template-columns: repeat(4, 1fr); gap: 8px; }
      /* Force grid items to stack to avoid overlaps from inline grid-column spans */
      .grid > * { grid-column: 1 / -1 !important; }
      .inline { gap: 6px; }
      label { margin-bottom: 4px; }
      input, textarea, select { font-size: 16px; }
      .btn { width: 100%; justify-content: center; }
    }
  </style>
</head>
<body>
  <h1>Scripture Styler ... browser edition <span class="badge" id="themeBadge">dark</span></h1>
  <div class="muted" style="margin: 6px 0 12px 0;">
    If this helps you, consider supporting:
    <a href="https://ko-fi.com/gille" target="_blank" rel="noopener noreferrer">ko-fi.com/gille</a>
    &nbsp;•&nbsp;
    <a href="https://github.com/helix4u/Bible-Styler/blob/main/README.md" target="_blank" rel="noopener noreferrer">README</a>
  </div>

  <div class="grid">
    <!-- Setup summary toggle -->
    <div class="row card" id="setupSummary">
      <div class="inline" style="justify-content: space-between; width:100%;">
        <div class="inline">
          <button id="setupToggle" class="btn secondary" aria-expanded="false" aria-controls="setupApiCard setupDataCard">Setup & Settings ▸</button>
          <span class="muted">API, models, persona, data, options</span>
        </div>
        <div class="inline">
          <label for="themeSelect" style="margin:0;">Theme</label>
          <select id="themeSelect"></select>
          <label for="fontSelect" style="margin:0 0 0 12px;">UI font</label>
          <select id="fontSelect">
            <option value="sans">Sans</option>
            <option value="serif">Serif</option>
            <option value="readable">Readable</option>
            <option value="humanist">Humanist</option>
            <option value="rounded">Rounded</option>
            <option value="condensed">Condensed</option>
            <option value="modern">Modern</option>
            <option value="slab">Slab</option>
            <option value="elegant">Elegant</option>
            <option value="display">Display</option>
            <option value="script">Script</option>
            <option value="mono">Mono</option>
            <option value="tech">Tech Mono</option>
          </select>
        </div>
      </div>
    </div>

    <div class="row card" id="presetQuickCard">
      <div class="grid" style="align-items: flex-end;">
        <div style="grid-column: span 8; min-width:220px;">
          <label for="presetQuick">Style preset</label>
          <select id="presetQuick"></select>
        </div>
        <div style="grid-column: span 4; display:flex; justify-content:flex-end; align-items:flex-end;">
          <button id="openPresetSettings" class="btn secondary" style="width:100%; max-width:200px;">Manage personas</button>
        </div>
      </div>
    </div>

    <!-- provider presets and api config -->
    <div class="row card" id="setupApiCard" style="display:none;">
      <div class="grid">
        <div style="grid-column: span 4;">
          <label for="vendor">Vendor preset</label>
          <select id="vendor">
            <option>Custom</option>
            <option>LM Studio ... local</option>
            <option>Ollama ... OpenAI compat</option>
            <option>OpenAI</option>
            <option>OpenRouter</option>
            <option>Together</option>
            <option>Groq</option>
            <option>Fireworks</option>
            <option>DeepInfra</option>
            <option>Cerebras</option>
          </select>
        </div>
        <div style="grid-column: span 5;">
          <label for="apiBase">API base ... OpenAI compatible chat completions</label>
          <input id="apiBase" placeholder="Example: http://127.0.0.1:1234/v1/chat/completions" spellcheck="false" autocomplete="off">
        </div>
        <div style="grid-column: span 3;">
          <label>Fetch models</label>
          <div class="inline">
            <button id="fetchModels" class="btn secondary">Fetch</button>
            <span id="modelsStatus" class="muted" aria-live="polite"></span>
          </div>
        </div>

        <div style="grid-column: span 6;">
          <label for="apiKey">API key ... stored only in this browser</label>
          <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off">
        </div>


        <!-- model selector with mobile-safe select and an optional free-typing input -->
        <div style="grid-column: span 3;">
          <label for="modelSelect">Model</label>
          <select id="modelSelect"></select>
          <input id="modelText" style="display:none; margin-top:8px;" placeholder="type a model id..." spellcheck="false" autocomplete="off">
          <div class="inline" style="margin-top:6px;">
            <input id="customModelToggle" type="checkbox" style="width:auto;">
            <label for="customModelToggle" style="margin:0;">type custom</label>
          </div>
        </div>

        <div style="grid-column: span 3;">
          <label for="temperature">Temperature</label>
          <input id="temperature" type="number" step="0.1" min="0" max="2" value="0.9">
        </div>

        <div style="grid-column: span 3;">
          <label for="stream">Stream tokens</label>
          <select id="stream">
            <option value="true" selected>true</option>
            <option value="false">false</option>
          </select>
        </div>

        <div style="grid-column: span 12;">
          <label for="systemPrompt">Style system prompt</label>
          <textarea id="systemPrompt" class="mono"></textarea>
        </div>

        <!-- persona slots management -->
        <div style="grid-column: span 12;">
          <label>Saved persona slots (local to this browser)</label>
          <div class="inline">
            <select id="slotSelect"></select>
            <button id="saveSlot" class="btn">Save to slot</button>
            <button id="loadSlot" class="btn secondary">Load slot</button>
            <button id="renameSlot" class="btn secondary">Rename</button>
            <button id="clearSlot" class="btn danger">Clear</button>
          </div>
        </div>

        <div style="grid-column: span 12;">
          <label for="stops">Stops ... comma separated</label>
          <input id="stops" value="Reference:,AI:,---">
        </div>

        <!-- Optional Settings Section -->
        <div style="grid-column: span 12;">
          <div class="inline" style="justify-content: space-between; width:100%; align-items:center; margin-bottom: 8px;">
            <span style="font-size: 14px; font-weight: 600; color: var(--text-muted);">Optional Settings</span>
            <button type="button" id="optionalSettingsToggle" class="btn secondary" aria-expanded="false" aria-controls="optionalSettingsContent">Show optional ▸</button>
          </div>
          <div id="optionalSettingsContent" style="display:none;">
            <div class="grid" style="gap: 12px; margin-top: 8px;">
              <div style="grid-column: span 6;">
                <label for="themeOverrides">Theme overrides (CSS vars JSON)</label>
                <textarea id="themeOverrides" class="mono" placeholder='{"--accent":"#22d3ee","--bg":"#0b0f14"}'></textarea>
              </div>
              <div style="grid-column: span 6;">
                <label for="extraHeaders">Extra headers (JSON object)</label>
                <textarea id="extraHeaders" class="mono" placeholder='{"HTTP-Referer":"https://your.site","X-Title":"Scripture Styler"}'></textarea>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="muted">Do not commit keys. This page saves to localStorage on this device only.</div>
    </div>
    
    <div class="row card" id="httpsWarn" style="display:none;">
      Heads up ... this page is HTTPS. Calls to http://localhost are often blocked by browsers. Prefer an HTTPS API endpoint or test the page locally over http.
    </div>

    <!-- data source -->
    <div class="row card" id="setupDataCard" style="display:none;">
      <div class="grid">
        <div style="grid-column: span 8;">
          <label for="jsonPreset">Default sources</label>
          <select id="jsonPreset"></select>
        </div>
        <div style="grid-column: span 8;">
          <label for="jsonUrl">Scripture JSON URL</label>
          <input id="jsonUrl" class="mono" value="https://raw.githubusercontent.com/helix4u/Bible-Styler/main/bible_kjv.json" spellcheck="false">
        </div>
        <div style="grid-column: span 4;">
          <label>Load JSON</label>
          <div class="inline">
            <button id="loadJson" class="btn secondary">Fetch</button>
            <input id="jsonFile" type="file" accept=".json">
          </div>
        </div>
        <div style="grid-column: span 4;">
          <label for="autoFetchJson">Auto-fetch JSON on load</label>
          <select id="autoFetchJson">
            <option value="false">false</option>
            <option value="true">true</option>
          </select>
        </div>
        <div style="grid-column: span 6;">
          <label for="volumes">Include volumes ... e.g. Old Testament,New Testament</label>
          <input id="volumes" value="Old Testament,New Testament">
        </div>
        <div style="grid-column: span 6;">
          <label for="books">Limit to books ... optional ... e.g. Genesis,Exodus</label>
          <input id="books" placeholder="Genesis,Exodus">
        </div>
        <div style="grid-column: span 4;">
          <label for="startIndex">Start index ... 0 based</label>
          <input id="startIndex" type="number" min="0" value="0">
        </div>
        <div style="grid-column: span 4;">
          <label for="endIndex">End before index ... optional</label>
          <input id="endIndex" type="number" min="0" placeholder="">
        </div>
        <div style="grid-column: span 4;">
          <label for="ctxPairs">Context pairs memory</label>
          <input id="ctxPairs" type="number" min="0" value="3">
        </div>
      </div>
      <div class="muted">JSON must be an array with keys ... book_title, chapter_number, verse_number, scripture_text.</div>
    </div>

    <!-- mode tabs -->
    <div class="row card">
      <div class="tabs">
        <div class="tab" data-panel="batchPanel" tabindex="0">Batch mode</div>
        <div class="tab active" data-panel="singlePanel" tabindex="0">Single verse/chapter</div>
      </div>

      <div id="batchPanel" style="display:none;">
        <div class="inline" style="margin-bottom: 8px;">
          <button id="startBtn" class="btn">Start</button>
          <button id="stopBtn" class="btn danger" disabled>Stop</button>
          <button id="downloadBtn" class="btn secondary" disabled>Download .txt</button>
        </div>
        <div id="status" class="muted" style="margin-top:8px;" aria-live="polite"></div>
      </div>

      <div id="singlePanel" style="display:block;">
        <div class="grid" style="margin-bottom: 8px;">
          <div style="grid-column: span 4;">
            <label for="bookSel">Book</label>
            <select id="bookSel"></select>
          </div>
          <div style="grid-column: span 4;">
            <label for="chapterSel">Chapter</label>
            <select id="chapterSel"></select>
          </div>
          <div style="grid-column: span 4;">
            <label for="verseSel">Verse</label>
            <select id="verseSel"></select>
          </div>
          <div style="grid-column: span 12;">
            <label for="singleText">Text override ... optional</label>
            <textarea id="singleText" class="mono" placeholder="Leave empty to use text from JSON"></textarea>
          </div>
        </div>
        <div class="inline" style="margin-bottom: 8px;">
          <button id="runSingle" class="btn ok">Run single verse</button>
          <button id="runChapter" class="btn neutral">Run chapter</button>
          <div class="inline" style="gap:8px; align-items:center;">
            <label for="maxPerRun" style="margin:0;" class="muted">Max verses/run</label>
            <input id="maxPerRun" type="number" min="1" value="50" style="width:96px;">
          </div>
          <div class="inline" style="gap:8px; align-items:center;">
            <input id="clearBeforeNext" type="checkbox">
            <label for="clearBeforeNext" style="margin:0;" class="muted">Clear before next chunk</label>
          </div>
          <button id="nextChunk" class="btn secondary" style="display:none;">Next chunk</button>
        </div>
        <div id="singleStatus" class="muted" aria-live="polite"></div>
      </div>
    </div>

    <!-- output -->
    <div class="row card">
      <label>Output</label>
      <div class="inline" style="margin: 8px 0;">
        <button id="copyOut" class="btn secondary">Copy output</button>
        <button id="shareOut" class="btn neutral">Share</button>
        <button id="readOut" class="btn">Read aloud</button>
        <button id="stopTts" class="btn danger">Stop TTS</button>
        <span id="outStatus" class="muted" aria-live="polite"></span>
      </div>
      <div id="out" class="out"></div>
    </div>

    <!-- study aids -->
    <div class="row card" id="studyCard">
      <label>Study Aids</label>
      <div class="grid" style="margin-bottom:8px;">
        <div style="grid-column: span 4;">
          <label for="studyPreset">Preset</label>
          <select id="studyPreset">
            <option value="qa">Q&A (answer a question)</option>
            <option value="sermon">Sermon prep</option>
            <option value="exegetical">Exegetical (verse-by-verse)</option>
            <option value="youth">Youth version</option>
            <option value="academic">Academic commentary</option>
            <option value="outline">Concise outline</option>
            <option value="crossrefs">Cross-references digest</option>
          </select>
        </div>
        <div style="grid-column: span 8;">
          <label for="studyQuestion">Question (optional)</label>
          <input id="studyQuestion" placeholder="Ask about these passages (e.g., themes, context, application)" autocomplete="off">
        </div>
        <div style="grid-column: span 4;">
          <label for="studyScope">Scope</label>
          <select id="studyScope">
            <option value="out">All styled output</option>
            <option value="chapter">Current chapter</option>
            <option value="verse">Current verse</option>
          </select>
        </div>
        <div style="grid-column: span 4;">
          <label for="studyContext">Context source</label>
          <select id="studyContext">
            <option value="both">Styled + original</option>
            <option value="styled">Styled only</option>
            <option value="original">Original only</option>
          </select>
        </div>
        <div style="grid-column: span 4;">
          <label for="studyCrossrefs">Include cross-references</label>
          <div class="inline">
            <input id="studyCrossrefs" type="checkbox" style="width:auto;" checked>
            <span class="muted">Suggest related passages when relevant</span>
          </div>
        </div>
        <div style="grid-column: span 4;">
          <label for="studyCrossrefLimit">Cross-reference limit</label>
          <input id="studyCrossrefLimit" type="number" min="0" max="12" value="4" aria-describedby="studyCrossrefLimitHint">
          <div id="studyCrossrefLimitHint" class="muted">0 keeps them optional; otherwise cap suggestions.</div>
        </div>
        <div style="grid-column: span 4;">
          <label for="studyCitationStyle">Citation style</label>
          <select id="studyCitationStyle">
            <option value="auto">Auto (match tradition)</option>
            <option value="brackets">Bracketed [Book C:V]</option>
            <option value="colon">Book C:V</option>
            <option value="narrative">Book Chapter Verse (words)</option>
          </select>
        </div>
      </div>
      <div class="inline" style="margin-bottom:8px;">
        <button id="runStudy" class="btn ok">Run study</button>
        <button id="copyStudy" class="btn secondary">Copy study</button>
        <button id="shareStudy" class="btn neutral">Share</button>
        <button id="readStudy" class="btn">Read aloud</button>
        <button id="stopStudyTts" class="btn danger">Stop TTS</button>
        <span id="studyStatus" class="muted" aria-live="polite"></span>
      </div>
      <div id="studyOut" class="out"></div>
    </div>
  </div>

  <script>
    // ---------- helpers
    function normalizeAscii(s) {
      return String(s)
        .replace(/\u2018|\u2019/g, "'")
        .replace(/\u201C|\u201D/g, '"')
        .replace(/\u2013|\u2014/g, "...")
        .replace(/\u00A0/g, " ");
    }
    function sanitizeOneLine(s) {
      if (!s) return "";
      s = normalizeAscii(s);
      s = s.replace(/\r/g, " ").replace(/\n/g, " ").trim();
      s = s.replace(/\s*---.*$/i, "");
      s = s.replace(/^\s*(AI|Answer|Output)\s*:\s*/i, "");
      s = s.replace(/\s*Reference\s*:.*$/i, "");
      s = Array.from(s).filter(ch => ch.codePointAt(0) < 0x2500).join("");
      return s.trim();
    }
    function refString(book, chapter, verse) { return `${book} ${chapter}:${verse}`; }
    function verseRef(row) {
      if (!row) return '';
      const titled = String(row.verse_title || '').trim();
      if (titled) return titled;
      const book = String(row.book_title || '').trim() || 'Unknown';
      const chapter = Number(row.chapter_number || 0) || 0;
      const verse = Number(row.verse_number || 0) || 0;
      return refString(book, chapter, verse);
    }
    function openingNgram(s, n = 4) {
      const toks = s.trim().split(/\s+/).filter(Boolean);
      return toks.slice(0, n).join(" ").toLowerCase();
    }
    function parseJSONOrEmpty(str) {
      const t = String(str || '').trim();
      if (!t) return {};
      try { return JSON.parse(t); } catch { return {}; }
    }

    function guessPresetKeyFromPrompt(prompt) {
      const text = String(prompt || '').trim();
      if (!text) return 'custom';
      for (const meta of PRESET_META) {
        const preset = PRESET_TEXTS[meta.key];
        if (preset && preset.trim() === text) return `preset:${meta.key}`;
      }
      if (Array.isArray(personaSlots)) {
        for (let i = 0; i < personaSlots.length; i++) {
          const slot = personaSlots[i];
          if (slot && slot.prompt && String(slot.prompt).trim() === text) {
            return `slot:${i}`;
          }
        }
      }
      return 'custom';
    }

    function syncQuickPresetSelection() {
      if (!presetQuickSelect) return;
      let desired = activePresetKey || '';
      let hasOption = false;
      presetQuickSelect.querySelectorAll('option').forEach(opt => {
        if (opt.value === desired) hasOption = true;
      });
      if (!hasOption) desired = '';
      presetQuickSelect.value = desired;
    }

    function updateQuickPresetOptions() {
      if (!presetQuickSelect) return;
      presetQuickSelect.innerHTML = '';

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select a preset';
      placeholder.disabled = true;
      placeholder.hidden = true;
      presetQuickSelect.appendChild(placeholder);

      const builtinGroup = document.createElement('optgroup');
      builtinGroup.label = 'Built-in presets';
      PRESET_META.forEach(meta => {
        const opt = document.createElement('option');
        opt.value = `preset:${meta.key}`;
        opt.textContent = meta.label;
        builtinGroup.appendChild(opt);
      });
      presetQuickSelect.appendChild(builtinGroup);

      if (Array.isArray(personaSlots)) {
        const filled = personaSlots
          .map((slot, idx) => ({ slot, idx }))
          .filter(item => item.slot && item.slot.prompt && item.slot.prompt.trim().length);
        if (filled.length) {
          const slotsGroup = document.createElement('optgroup');
          slotsGroup.label = 'Saved slots';
          filled.forEach(({ slot, idx }) => {
            const opt = document.createElement('option');
            opt.value = `slot:${idx}`;
            const label = slot.name ? slot.name : `Persona ${idx + 1}`;
            opt.textContent = `Slot ${idx + 1}: ${label}`;
            slotsGroup.appendChild(opt);
          });
          presetQuickSelect.appendChild(slotsGroup);
        }
      }

      syncQuickPresetSelection();
    }

    function applyPresetByKey(key) {
      key = key || 'custom';
      if (key === 'custom') {
        activePresetKey = 'custom';
        syncQuickPresetSelection();
        saveSettings();
        return;
      }
      if (key.startsWith('preset:')) {
        const k = key.slice('preset:'.length);
        const preset = PRESET_TEXTS[k];
        if (preset) {
          systemPromptEl.value = preset;
          activePresetKey = key;
          syncQuickPresetSelection();
          saveSettings();
          return;
        }
      }
      if (key.startsWith('slot:')) {
        const idx = parseInt(key.slice('slot:'.length), 10);
        const slot = Array.isArray(personaSlots) ? personaSlots[idx] : null;
        if (!slot || !slot.prompt) {
          alert('Selected slot is empty.');
          activePresetKey = guessPresetKeyFromPrompt(systemPromptEl.value);
          syncQuickPresetSelection();
          saveSettings();
          return;
        }
        systemPromptEl.value = slot.prompt;
        activePresetKey = key;
        syncQuickPresetSelection();
        saveSettings();
        return;
      }
      activePresetKey = 'custom';
      syncQuickPresetSelection();
      saveSettings();
    }

    // ---------- persona presets
    const PRESET_TEXTS = {
      stoner:
`You are rewriting each scripture verse in a stoner voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Do not narrate what you are doing. Just do it... and do it with exaggerated tone.`,
      zoomer:
`You are rewriting each scripture verse in a zoomer voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Use tight, internet-native phrasing with occasional slang and lowercasing where natural, but keep names correctly cased. No emojis. No slurs.`,
      houseish:
`You are rewriting each scripture verse in the voice of a cynical, brilliant diagnostician from a medical drama. Dry, acerbic, brutally honest, skeptical of neat moral explanations, but precise. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. Inject cutting diagnostic metaphors and bleak wit, but stay faithful to facts. No emojis. No slurs.`,

      // --- useful/accessible tones
      plain:
`You are rewriting each scripture verse in plain modern English. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Short, clear sentences. Make every line unique. No Repetition. No emojis. No slurs.`,
      kid:
`You are rewriting each scripture verse for kids. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Use simple words and short, friendly phrases. Make every line unique. No Repetition. No emojis. No slurs.`,
      headline:
`You are rewriting each scripture verse as a news headline. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Compact and punchy; ~12-18 words. Make every line unique. No Repetition. No emojis. No slurs.`,
      legal:
`You are rewriting each scripture verse in the tone of a formal legal brief. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Precise, neutral wording; use whereas/therefore sparingly. Make every line unique. No Repetition. No emojis. No slurs.`,
      study:
`You are rewriting each scripture verse as a concise study note. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Clarify relationships with plain connectors (because, therefore, but). Make every line unique. No Repetition. No emojis. No slurs.`,
      clinical:
`You are rewriting each scripture verse in a clinical, scientific tone. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Neutral cause-and-effect phrasing; avoid metaphor. Make every line unique. No Repetition. No emojis. No slurs.`,
      minimalist:
`You are rewriting each scripture verse in a minimalist style. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. 15-25 words max; remove filler; keep structure clear. Make every line unique. No Repetition. No emojis. No slurs.`,
      tweet:
`You are rewriting each scripture verse as a tweet-length line (<=180 chars). Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Make every line unique. No Repetition. No emojis. No slurs.`,

      // --- fun/voicey tones
      bard:
`You are rewriting each scripture verse in a Shakespeare-like bardic voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Use thee/thy/'tis where natural. Make every line unique. No Repetition. No emojis. No slurs.`,
      pirate:
`You are rewriting each scripture verse in a clean pirate voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Light nautical slang; no profanity. Make every line unique. No Repetition. No emojis. No slurs.`,
      noir:
`You are rewriting each scripture verse in a noir detective voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Short, moody, hardboiled cadence. Make every line unique. No Repetition. No emojis. No slurs.`,
      coach:
`You are rewriting each scripture verse as a sports coach pep-talk. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Upbeat, imperative metaphors; clean language. Make every line unique. No Repetition. No emojis. No slurs.`,
      stoic:
`You are rewriting each scripture verse in a stoic, aphoristic voice. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Calm, terse, disciplined tone. Make every line unique. No Repetition. No emojis. No slurs.`,
      hacker:
`You are rewriting each scripture verse like a concise system log. Keep all proper nouns unchanged. One output line per verse. No extra commentary. Keep info density similar to the source. Do not add or remove facts. Use bracketed tags and status-like phrasing sparingly. Make every line unique. No Repetition. No emojis. No slurs.`
    };

    const PRESET_META = [
      { key: 'stoner', label: 'Stoner (default)' },
      { key: 'zoomer', label: 'Zoomer' },
      { key: 'houseish', label: 'Cynical TV Doctor (House-ish)' },
      { key: 'plain', label: 'Plain English' },
      { key: 'kid', label: 'Kid-Friendly' },
      { key: 'headline', label: 'Headline' },
      { key: 'legal', label: 'Legal Brief' },
      { key: 'study', label: 'Study Note' },
      { key: 'clinical', label: 'Clinical/Scientific' },
      { key: 'minimalist', label: 'Minimalist' },
      { key: 'tweet', label: 'Tweet-Length' },
      { key: 'bard', label: 'Bold Bard' },
      { key: 'pirate', label: 'Pirate' },
      { key: 'noir', label: 'Noir Detective' },
      { key: 'coach', label: 'Sports Coach' },
      { key: 'stoic', label: 'Stoic Sage' },
      { key: 'hacker', label: 'Hacker Log' }
    ];

    // ---------- study presets (cross-cultural, neutral)
    const STUDY_PRESETS = {
      qa:
`You are a neutral, cross-cultural scripture study aide. Answer the user's question using only the provided passages and plainly inferred themes. Be respectful and inclusive. Avoid speculative doctrine; do not assert tradition-specific claims as facts. Cite verse references inline like [Book C:V] when supporting points. Keep answers clear and practical. If information is insufficient, say so briefly.`,
      sermon:
`You are preparing a cross-culturally respectful teaching outline based on the provided passages. Return: 1) Big idea (one line), 2) 3–5 teaching points with brief, practical applications, 3) illustration ideas (universal, non-denominational), 4) reflection questions, 5) related cross-references where clearly relevant. Keep language accessible and concise; cite references like [Book C:V]. Avoid doctrinal assertions not grounded in the text.`,
      exegetical:
`Provide a verse-by-verse exegetical walkthrough for the provided passages. For each verse: note key terms, literary or rhetorical features, immediate context, and concise observations grounded in the text. After the walkthrough, give: structure outline, key themes, and related cross-references (when clearly supported by the text). Use neutral, cross-cultural language; avoid tradition-specific claims. Cite like [Book C:V].`,
      youth:
`Rewrite a simple, age-appropriate summary of the provided passages, then give 3–5 discussion questions and 2–3 practical, everyday applications. Keep it respectful, kind, and inclusive; avoid slang that might not travel across cultures. Keep facts aligned with the text; cite references like [Book C:V] sparingly in parentheses.`,
      academic:
`Offer a concise academic-style commentary of the provided passages: genre and structure, notable literary devices, intertextual echoes (if apparent from the text), key terms and semantic contrasts, and thematic synthesis. Keep claims grounded in the provided text; avoid unverified historical claims. Include brief, text-grounded cross-references if clearly relevant. Cite like [Book C:V].`,
      outline:
`Produce a concise outline of the provided passages: title, 3–7 hierarchical bullet points (no more than two levels), and a short summary paragraph. Add 2–4 related cross-references if clearly relevant. Keep language neutral and broadly applicable. Use [Book C:V] to cite.`,
      crossrefs:
`List 5–10 related cross-references that are likely relevant to the provided passages, explaining each link in one short sentence. Prefer references within the same corpus; if uncertain, focus on nearby passages that share key terms or themes. Keep language neutral and avoid tradition-specific assertions. Cite like [Book C:V].`
    };

    // ---------- themes
    const THEMES = {
      dark: {
        '--bg':'#0b0f14','--bg-elev':'#0f172a','--bg-input':'#0b1220','--border':'#1e293b','--border-strong':'#334155','--text':'#e5e7eb','--text-muted':'#94a3b8','--accent':'#38bdf8','--accent-2':'#22d3ee','--danger':'#f43f5e','--ok':'#34d399','--term':'#a7f3d0','--term-bg':'#071019',
        '--btn-bg':'#38bdf8','--btn-bg-2':'#22d3ee','--btn-fg':'#001018','--btn-secondary-fg':'#e5e7eb',
        '--btn-danger-top':'#fb7185','--btn-danger-bg':'#f43f5e','--btn-danger-fg':'#1b0310',
        '--btn-ok-top':'#6ee7b7','--btn-ok-bg':'#34d399','--btn-ok-fg':'#032018',
        '--link':'#22c55e'
      },
      light: {
        '--bg':'#f8fafc','--bg-elev':'#ffffff','--bg-input':'#f1f5f9','--border':'#e5e7eb','--border-strong':'#cbd5e1','--text':'#0f172a','--text-muted':'#475569','--accent':'#0ea5e9','--accent-2':'#22d3ee','--danger':'#dc2626','--ok':'#059669','--term':'#0f172a','--term-bg':'#e2e8f0',
        '--btn-bg':'#0ea5e9','--btn-bg-2':'#22d3ee','--btn-fg':'#0f172a','--btn-secondary-fg':'#0f172a',
        '--btn-danger-top':'#fca5a5','--btn-danger-bg':'#dc2626','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#a7f3d0','--btn-ok-bg':'#059669','--btn-ok-fg':'#ffffff',
        '--link':'#15803d'
      },
      cyberpunk: {
        '--bg':'#0a1420','--bg-elev':'#0f1f30','--bg-input':'#0c1a2b','--border':'#203349','--border-strong':'#2f4b63','--text':'#cde7ff','--text-muted':'#6aa0bb','--accent':'#00eaff','--accent-2':'#00b7ff','--danger':'#ff2d55','--ok':'#00ffa3','--term':'#00eaff','--term-bg':'#071321',
        '--btn-bg':'#00eaff','--btn-bg-2':'#00b7ff','--btn-fg':'#001018','--btn-secondary-fg':'#9de9ff',
        '--btn-danger-top':'#ff506e','--btn-danger-bg':'#ff2d55','--btn-danger-fg':'#1f0a12',
        '--btn-ok-top':'#33ffb7','--btn-ok-bg':'#00ffa3','--btn-ok-fg':'#001a12',
        '--link':'#00ffa3'
      },
      onyx: {
        '--bg':'#000000','--bg-elev':'#0a0a0a','--bg-input':'#0f0f10','--border':'#1a1a1b','--border-strong':'#2a2a2b','--text':'#e6e6e6','--text-muted':'#9ca3af','--accent':'#9ca3af','--accent-2':'#6b7280','--danger':'#ef4444','--ok':'#10b981','--term':'#c7d2fe','--term-bg':'#060606',
        '--btn-bg':'#22d3ee','--btn-bg-2':'#22d3ee','--btn-fg':'#ffffff','--btn-secondary-fg':'#e6e6e6',
        '--btn-danger-top':'#fb7185','--btn-danger-bg':'#ef4444','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#6ee7b7','--btn-ok-bg':'#10b981','--btn-ok-fg':'#051b12',
        '--link':'#9ca3af',
        '--focus':'0 0 0 3px rgba(156, 163, 175, 0.35)'
      },
      sepia: {
        '--bg':'#f7f2e7','--bg-elev':'#fffdf7','--bg-input':'#f2eadf','--border':'#e8dcc6','--border-strong':'#d6c7ad','--text':'#2f2a24','--text-muted':'#6b5e52','--accent':'#b26b00','--accent-2':'#d97706','--danger':'#b45309','--ok':'#2f7d32','--term':'#3b2f2f','--term-bg':'#efe6d8',
        '--btn-bg':'#b26b00','--btn-bg-2':'#d97706','--btn-fg':'#2f2a24','--btn-secondary-fg':'#2f2a24',
        '--btn-danger-top':'#f59e0b','--btn-danger-bg':'#b45309','--btn-danger-fg':'#2f2a24',
        '--btn-ok-top':'#a8d5a2','--btn-ok-bg':'#2f7d32','--btn-ok-fg':'#ffffff',
        '--link':'#2f7d32'
      },
      highcontrast: {
        '--bg':'#000000','--bg-elev':'#000000','--bg-input':'#000000','--border':'#ffffff','--border-strong':'#ffffff','--text':'#ffffff','--text-muted':'#cfcfcf','--accent':'#ffff00','--accent-2':'#00ffff','--danger':'#ff0000','--ok':'#00ff00','--term':'#ffffff','--term-bg':'#000000',
        '--btn-bg':'#ffff00','--btn-bg-2':'#00ffff','--btn-fg':'#000000','--btn-secondary-fg':'#ffffff',
        '--btn-danger-top':'#ff7f7f','--btn-danger-bg':'#ff0000','--btn-danger-fg':'#000000',
        '--btn-ok-top':'#a7ffa7','--btn-ok-bg':'#00ff00','--btn-ok-fg':'#000000',
        '--link':'#00ff00'
      },
      neon: {
        '--bg':'#0a0a0a','--bg-elev':'#111111','--bg-input':'#1a1a1a','--border':'#ff00ff','--border-strong':'#00ffff','--text':'#ffffff','--text-muted':'#cccccc','--accent':'#ff0080','--accent-2':'#8000ff','--danger':'#ff1744','--ok':'#00ff41','--term':'#00ff00','--term-bg':'#000000',
        '--btn-bg':'#ff0080','--btn-bg-2':'#8000ff','--btn-fg':'#ffffff','--btn-secondary-fg':'#ffffff',
        '--btn-danger-top':'#ff4081','--btn-danger-bg':'#ff1744','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#69f0ae','--btn-ok-bg':'#00ff41','--btn-ok-fg':'#000000',
        '--link':'#00ffff'
      },
      forest: {
        '--bg':'#1a2e1a','--bg-elev':'#2d4a2d','--bg-input':'#1f3d1f','--border':'#4a6741','--border-strong':'#6b8e5a','--text':'#e8f5e8','--text-muted':'#a8c49a','--accent':'#7cb342','--accent-2':'#8bc34a','--danger':'#d32f2f','--ok':'#388e3c','--term':'#c8e6c9','--term-bg':'#1b5e20',
        '--btn-bg':'#7cb342','--btn-bg-2':'#8bc34a','--btn-fg':'#ffffff','--btn-secondary-fg':'#e8f5e8',
        '--btn-danger-top':'#ef5350','--btn-danger-bg':'#d32f2f','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#66bb6a','--btn-ok-bg':'#388e3c','--btn-ok-fg':'#ffffff',
        '--link':'#81c784'
      },
      ocean: {
        '--bg':'#0d1b2a','--bg-elev':'#1b263b','--bg-input':'#0f1419','--border':'#2d5aa0','--border-strong':'#4f81bd','--text':'#e0f2f1','--text-muted':'#90caf9','--accent':'#00acc1','--accent-2':'#26c6da','--danger':'#e53935','--ok':'#00897b','--term':'#b2dfdb','--term-bg':'#004d40',
        '--btn-bg':'#00acc1','--btn-bg-2':'#26c6da','--btn-fg':'#ffffff','--btn-secondary-fg':'#e0f2f1',
        '--btn-danger-top':'#ef5350','--btn-danger-bg':'#e53935','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#4db6ac','--btn-ok-bg':'#00897b','--btn-ok-fg':'#ffffff',
        '--link':'#4fc3f7'
      },
      sunset: {
        '--bg':'#2d1b69','--bg-elev':'#512da8','--bg-input':'#3f1a5b','--border':'#ff6f00','--border-strong':'#ff8f00','--text':'#fff3e0','--text-muted':'#ffcc02','--accent':'#ff5722','--accent-2':'#ff9800','--danger':'#d32f2f','--ok':'#689f38','--term':'#ffe0b2','--term-bg':'#bf360c',
        '--btn-bg':'#ff5722','--btn-bg-2':'#ff9800','--btn-fg':'#ffffff','--btn-secondary-fg':'#fff3e0',
        '--btn-danger-top':'#ef5350','--btn-danger-bg':'#d32f2f','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#9ccc65','--btn-ok-bg':'#689f38','--btn-ok-fg':'#ffffff',
        '--link':'#ffab40'
      },
      vintage: {
        '--bg':'#3e2723','--bg-elev':'#5d4037','--bg-input':'#4e342e','--border':'#8d6e63','--border-strong':'#a1887f','--text':'#efebe9','--text-muted':'#bcaaa4','--accent':'#d4af37','--accent-2':'#ffd700','--danger':'#c62828','--ok':'#558b2f','--term':'#d7ccc8','--term-bg':'#3e2723',
        '--btn-bg':'#d4af37','--btn-bg-2':'#ffd700','--btn-fg':'#3e2723','--btn-secondary-fg':'#efebe9',
        '--btn-danger-top':'#ef5350','--btn-danger-bg':'#c62828','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#9ccc65','--btn-ok-bg':'#558b2f','--btn-ok-fg':'#ffffff',
        '--link':'#ffb74d'
      },
      pastel: {
        '--bg':'#faf5ff','--bg-elev':'#f3e8ff','--bg-input':'#ede9fe','--border':'#d8b4fe','--border-strong':'#c084fc','--text':'#581c87','--text-muted':'#7c3aed','--accent':'#a855f7','--accent-2':'#c084fc','--danger':'#dc2626','--ok':'#059669','--term':'#581c87','--term-bg':'#f3e8ff',
        '--btn-bg':'#a855f7','--btn-bg-2':'#c084fc','--btn-fg':'#ffffff','--btn-secondary-fg':'#581c87',
        '--btn-danger-top':'#fca5a5','--btn-danger-bg':'#dc2626','--btn-danger-fg':'#ffffff',
        '--btn-ok-top':'#a7f3d0','--btn-ok-bg':'#059669','--btn-ok-fg':'#ffffff',
        '--link':'#7c3aed'
      }
    };
    function applyTheme(name, overrides) {
      const root = document.documentElement;
      const base = THEMES[name] || THEMES.dark;
      Object.entries(base).forEach(([k,v]) => root.style.setProperty(k, v));
      if (overrides && typeof overrides === 'object') {
        Object.entries(overrides).forEach(([k,v]) => {
          if (String(k).startsWith('--')) root.style.setProperty(k, v);
        });
      }
      const badge = document.getElementById('themeBadge');
      if (badge) badge.textContent = name;
    }
    
    function applyFont(fontFamily) {
      const root = document.documentElement;
      const fontVar = `--font-${fontFamily}`;
      const fontValue = getComputedStyle(root).getPropertyValue(fontVar).trim();
      if (fontValue) {
        root.style.setProperty('--font-sans', fontValue);
      }
    }

    // ---------- vendor presets
    const vendorPresets = {
      "Custom": {},
      "LM Studio ... local": { apiBase: "http://127.0.0.1:1234/v1/chat/completions" },
      "Ollama ... OpenAI compat": { apiBase: "http://127.0.0.1:11434/v1/chat/completions" },
      "OpenAI": { apiBase: "https://api.openai.com/v1/chat/completions" },
      "OpenRouter": {
        apiBase: "https://openrouter.ai/api/v1/chat/completions",
        extraHeaders: { "HTTP-Referer": location.origin || "https://example.com", "X-Title": "Scripture Styler" }
      },
      "Together": { apiBase: "https://api.together.xyz/v1/chat/completions" },
      "Groq": { apiBase: "https://api.groq.com/openai/v1/chat/completions" },
      "Fireworks": { apiBase: "https://api.fireworks.ai/inference/v1/chat/completions" },
      "DeepInfra": { apiBase: "https://api.deepinfra.com/v1/openai/chat/completions" },
      "Cerebras": { apiBase: "https://api.cerebras.ai/v1/chat/completions" }
    };

    // ---------- UI refs
    const vendorEl = document.getElementById('vendor');
    const apiBaseEl = document.getElementById('apiBase');
    const apiKeyEl = document.getElementById('apiKey');
    const themeSelectEl = document.getElementById('themeSelect');
    const fontSelectEl = document.getElementById('fontSelect');
    const themeOverridesEl = document.getElementById('themeOverrides');
    const optionalSettingsToggle = document.getElementById('optionalSettingsToggle');
    const setupToggleBtn = document.getElementById('setupToggle');
    const setupApiCard = document.getElementById('setupApiCard');
    const setupDataCard = document.getElementById('setupDataCard');
    const autoFetchJsonEl = document.getElementById('autoFetchJson');

    const modelSelectEl = document.getElementById('modelSelect');
    const modelTextEl = document.getElementById('modelText');
    const customModelToggle = document.getElementById('customModelToggle');

    const fetchModelsBtn = document.getElementById('fetchModels');
    const modelsStatus = document.getElementById('modelsStatus');

    const temperatureEl = document.getElementById('temperature');
    const streamEl = document.getElementById('stream');
    const systemPromptEl = document.getElementById('systemPrompt');
    const stopsEl = document.getElementById('stops');
    const extraHeadersEl = document.getElementById('extraHeaders');

    const presetQuickSelect = document.getElementById('presetQuick');
    const openPresetSettingsBtn = document.getElementById('openPresetSettings');
    const slotSelect = document.getElementById('slotSelect');
    const saveSlotBtn = document.getElementById('saveSlot');
    const loadSlotBtn = document.getElementById('loadSlot');
    const renameSlotBtn = document.getElementById('renameSlot');
    const clearSlotBtn = document.getElementById('clearSlot');

    const jsonUrlEl = document.getElementById('jsonUrl');
    const jsonPresetEl = document.getElementById('jsonPreset');
    const loadJsonBtn = document.getElementById('loadJson');
    const jsonFileEl = document.getElementById('jsonFile');
    const volumesEl = document.getElementById('volumes');
    const booksEl = document.getElementById('books');
    const startIndexEl = document.getElementById('startIndex');
    const endIndexEl = document.getElementById('endIndex');
    const ctxPairsEl = document.getElementById('ctxPairs');

    const outEl = document.getElementById('out');
    const copyOutBtn = document.getElementById('copyOut');
    const shareOutBtn = document.getElementById('shareOut');
    const readOutBtn = document.getElementById('readOut');
    const stopTtsBtn = document.getElementById('stopTts');
    const outStatus = document.getElementById('outStatus');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusEl = document.getElementById('status');

    const tabs = document.querySelectorAll('.tab');
    const batchPanel = document.getElementById('batchPanel');
    const singlePanel = document.getElementById('singlePanel');
    const bookSel = document.getElementById('bookSel');
    const chapterSel = document.getElementById('chapterSel');
    const verseSel = document.getElementById('verseSel');
    const singleTextEl = document.getElementById('singleText');
    const runSingleBtn = document.getElementById('runSingle');
    const runChapterBtn = document.getElementById('runChapter');
    const maxPerRunEl = document.getElementById('maxPerRun');
    const clearBeforeNextEl = document.getElementById('clearBeforeNext');
    const nextChunkBtn = document.getElementById('nextChunk');
    const singleStatus = document.getElementById('singleStatus');

    // Study UI refs
    const studyPresetEl = document.getElementById('studyPreset');
    const studyQuestionEl = document.getElementById('studyQuestion');
    const studyScopeEl = document.getElementById('studyScope');
    const studyContextEl = document.getElementById('studyContext');
    const studyCrossrefsEl = document.getElementById('studyCrossrefs');
    const studyCrossrefLimitEl = document.getElementById('studyCrossrefLimit');
    const studyCitationStyleEl = document.getElementById('studyCitationStyle');
    const runStudyBtn = document.getElementById('runStudy');
    const copyStudyBtn = document.getElementById('copyStudy');
    const shareStudyBtn = document.getElementById('shareStudy');
    const readStudyBtn = document.getElementById('readStudy');
    const stopStudyTtsBtn = document.getElementById('stopStudyTts');
    const studyOutEl = document.getElementById('studyOut');
    const studyStatusEl = document.getElementById('studyStatus');

    const httpsWarn = document.getElementById('httpsWarn');
    if (location.protocol === 'https:') httpsWarn.style.display = 'block';

    // clipboard + share helpers
    async function copyToClipboard(text) {
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
        } else {
          const ta = document.createElement('textarea');
          ta.value = text; ta.setAttribute('readonly', '');
          ta.style.position = 'fixed'; ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }
        return true;
      } catch { return false; }
    }
    function setOutStatus(msg) {
      outStatus.textContent = msg;
      if (!msg) return;
      setTimeout(() => { if (outStatus.textContent === msg) outStatus.textContent = ''; }, 2000);
    }
    async function shareOutput() {
      try {
        const txt = (outEl.textContent || '').trim();
        if (!txt) { setOutStatus('Nothing to share'); return; }
        // Text-only share (no file). Prefer native Web Share text path.
        if (navigator.share) {
          const snippet = txt.length > 100000 ? txt.slice(0, 100000) : txt;
          try {
            await navigator.share({ title: 'Scripture Styler', text: snippet });
            setOutStatus('Shared');
            return;
          } catch (err) {
            if (err && (err.name === 'AbortError' || err.name === 'NotAllowedError')) { setOutStatus(''); return; }
          }
        }
        // Fallback: copy to clipboard
        const ok = await copyToClipboard(txt);
        setOutStatus(ok ? 'Copied (share unavailable)' : 'Share/copy failed');
      } catch (e) {
        setOutStatus('Share failed');
      }
    }

    // helper: set and persist active panel (batchPanel | singlePanel)
    function setActivePanel(panel) {
      const list = Array.from(tabs);
      list.forEach(x => x.classList.remove('active'));
      const tab = list.find(x => x.dataset.panel === panel) || list[0];
      if (tab) tab.classList.add('active');
      batchPanel.style.display = panel === 'batchPanel' ? 'block' : 'none';
      singlePanel.style.display = panel === 'singlePanel' ? 'block' : 'none';
      try {
        const prev = (() => { try { return JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}'); } catch { return {}; } })();
        prev.activePanel = panel;
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(prev));
      } catch {}
    }

    // tabs toggle...use pointerup for better mobile behavior
    tabs.forEach(t => {
      const handler = () => {
        const panel = t.dataset.panel;
        setActivePanel(panel);
      };
      ['pointerup','click','keyup'].forEach(ev => t.addEventListener(ev, (e) => {
        if (ev === 'keyup' && e.key !== 'Enter' && e.key !== ' ') return;
        handler();
      }, { passive: true }));
    });

    // ---------- persistence
    const SETTINGS_KEY = 'bibleStylerSettings.v2';
    const SLOTS_KEY = 'personaSlots.v1'; // 5 slots
    let setupOpen = false;
    let optionalSettingsOpen = false;
    let activePresetKey = 'custom';
    let personaSlots = [];
    let lastSelectedModel = '';

    function getActiveModelId() {
      return customModelToggle.checked ? modelTextEl.value.trim() : modelSelectEl.value.trim();
    }

    function saveSettings() {
      const obj = {
        vendor: vendorEl.value,
        apiBase: apiBaseEl.value,
        apiKey: apiKeyEl.value,
        themeName: (themeSelectEl?.value || 'dark'),
        fontFamily: (fontSelectEl?.value || 'sans'),
        themeOverrides: (themeOverridesEl?.value || ''),
        setupOpen: !!setupOpen,
        modelMode: customModelToggle.checked ? 'custom' : 'select',
        modelSelect: modelSelectEl.value,
        modelText: modelTextEl.value,
        temperature: temperatureEl.value,
        stream: streamEl.value,
        systemPrompt: systemPromptEl.value,
        stops: stopsEl.value,
        jsonUrl: jsonUrlEl.value,
        autoFetchJson: (autoFetchJsonEl?.value || 'false'),
        volumes: volumesEl.value,
        books: booksEl.value,
        ctxPairs: ctxPairsEl.value,
        extraHeaders: extraHeadersEl.value,
        maxPerRun: (maxPerRunEl?.value || '50'),
        clearBeforeNext: (clearBeforeNextEl?.checked ? 'true' : 'false'),
        studyCrossrefs: (studyCrossrefsEl?.checked ? 'true' : 'false'),
        studyCrossrefLimit: (studyCrossrefLimitEl?.value || '4'),
        studyCitationStyle: (studyCitationStyleEl?.value || 'auto'),
        studyScope: (studyScopeEl?.value || 'out'),
        optionalSettingsOpen: optionalSettingsOpen ? 'true' : 'false',
        presetKey: activePresetKey || 'custom',
        // persist current panel selection as part of settings
        activePanel: (document.querySelector('.tab.active')?.dataset.panel) || 'singlePanel'
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj));
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (raw) {
          const s = JSON.parse(raw);
          vendorEl.value = s.vendor || 'Custom';
          apiBaseEl.value = s.apiBase || '';
          apiKeyEl.value = s.apiKey || '';
          // theme and font
          const themeName = (s.themeName || 'dark');
          const fontFamily = (s.fontFamily || 'sans');
          const themeOverrides = (() => { try { return JSON.parse(s.themeOverrides||''); } catch { return {}; }})();
          initThemeUI(themeName);
          applyTheme(themeName, themeOverrides);
          applyFont(fontFamily);
          if (fontSelectEl) fontSelectEl.value = fontFamily;
          if (themeOverridesEl) themeOverridesEl.value = s.themeOverrides || '';
          setupOpen = !!s.setupOpen;
          setSetupOpen(setupOpen);
          temperatureEl.value = s.temperature || '0.9';
          streamEl.value = s.stream || 'true';
          systemPromptEl.value = s.systemPrompt || PRESET_TEXTS.stoner; // default
          activePresetKey = s.presetKey || guessPresetKeyFromPrompt(systemPromptEl.value);
          stopsEl.value = s.stops || 'Reference:,AI:,---';
          jsonUrlEl.value = s.jsonUrl || jsonUrlEl.value;
          if (autoFetchJsonEl) autoFetchJsonEl.value = s.autoFetchJson || 'false';
          volumesEl.value = s.volumes || 'Old Testament,New Testament';
          booksEl.value = s.books || '';
          ctxPairsEl.value = s.ctxPairs || '3';
          extraHeadersEl.value = s.extraHeaders || '';
          if (maxPerRunEl) maxPerRunEl.value = s.maxPerRun || '50';
          if (clearBeforeNextEl) clearBeforeNextEl.checked = (s.clearBeforeNext === 'true');
          if (studyScopeEl) studyScopeEl.value = s.studyScope || 'out';
          if (studyCrossrefsEl) studyCrossrefsEl.checked = (s.studyCrossrefs !== 'false');
          if (studyCrossrefLimitEl) studyCrossrefLimitEl.value = s.studyCrossrefLimit || '4';
          if (studyCitationStyleEl) studyCitationStyleEl.value = s.studyCitationStyle || 'auto';
          optionalSettingsOpen = (s.optionalSettingsOpen === 'true');
          setOptionalSettingsOpen(optionalSettingsOpen);
          // model mode
          const mode = s.modelMode || 'select';
          customModelToggle.checked = mode === 'custom';
          modelTextEl.value = s.modelText || '';
          modelSelectEl.value = s.modelSelect || '';
          lastSelectedModel = modelSelectEl.value || '';
          updateModelInputsVisibility();
          // restore last active panel (batch vs single) — default single first
          setActivePanel(s.activePanel || 'singlePanel');
        } else {
          systemPromptEl.value = PRESET_TEXTS.stoner; // first load default
          lastSelectedModel = modelSelectEl.value || '';
          setOptionalSettingsOpen(false);
        }
      } catch {
        systemPromptEl.value = PRESET_TEXTS.stoner;
        lastSelectedModel = modelSelectEl.value || '';
        setOptionalSettingsOpen(false);
      }
    }

    function initThemeUI(selected) {
      if (!themeSelectEl) return;
      const options = [
        {v:'dark', t:'Dark'},
        {v:'light', t:'Light'},
        {v:'cyberpunk', t:'Cyberpunk'},
        {v:'onyx', t:'Onyx Black'},
        {v:'sepia', t:'Sepia'},
        {v:'highcontrast', t:'High Contrast'},
        {v:'neon', t:'Neon Nights'},
        {v:'forest', t:'Forest Grove'},
        {v:'ocean', t:'Deep Ocean'},
        {v:'sunset', t:'Purple Sunset'},
        {v:'vintage', t:'Vintage Gold'},
        {v:'pastel', t:'Pastel Dreams'}
      ];
      themeSelectEl.innerHTML = options.map(o => `<option value="${o.v}">${o.t}</option>`).join('');
      themeSelectEl.value = options.some(o=>o.v===selected) ? selected : 'dark';
    }

    function setSetupOpen(open) {
      setupOpen = !!open;
      if (setupApiCard) setupApiCard.style.display = open ? 'block' : 'none';
      if (setupDataCard) setupDataCard.style.display = open ? 'block' : 'none';
      if (setupToggleBtn) {
        setupToggleBtn.textContent = open ? 'Setup & Settings ▾' : 'Setup & Settings ▸';
        setupToggleBtn.setAttribute('aria-expanded', String(open));
      }
      // Only show HTTPS warning when setup section is visible and protocol is https
      if (httpsWarn) httpsWarn.style.display = (open && location.protocol === 'https:') ? 'block' : 'none';
    }

    function setOptionalSettingsOpen(open) {
      optionalSettingsOpen = !!open;
      const optionalContent = document.getElementById('optionalSettingsContent');
      if (optionalSettingsToggle) {
        optionalSettingsToggle.textContent = open ? 'Hide optional ▾' : 'Show optional ▸';
        optionalSettingsToggle.setAttribute('aria-expanded', String(open));
      }
      if (optionalContent) {
        optionalContent.style.display = open ? 'block' : 'none';
        optionalContent.setAttribute('aria-hidden', String(!open));
      }
    }

    setOptionalSettingsOpen(false);

    function updateModelInputsVisibility() {
      if (customModelToggle.checked) {
        if (modelTextEl && modelSelectEl) {
          const current = (modelTextEl.value || '').trim();
          const candidate = modelSelectEl.value || lastSelectedModel || '';
          if (!current && candidate) {
            modelTextEl.value = candidate;
          }
          if (modelTextEl.value) {
            lastSelectedModel = modelTextEl.value;
          }
        }
        modelTextEl.style.display = 'block';
        modelSelectEl.style.display = 'none';
      } else {
        modelTextEl.style.display = 'none';
        modelSelectEl.style.display = 'block';
      }
    }

    // persist most fields
    document.querySelectorAll('input,textarea,select').forEach(el => {
      el.addEventListener('change', saveSettings, { passive: true });
      el.addEventListener('input', saveSettings, { passive: true }); // save while typing to retain on refresh
    });
    if (modelSelectEl) modelSelectEl.addEventListener('change', () => {
      lastSelectedModel = modelSelectEl.value;
    }, { passive: true });
    if (modelTextEl) modelTextEl.addEventListener('change', () => {
      if (customModelToggle.checked) {
        lastSelectedModel = modelTextEl.value;
      }
    }, { passive: true });
    // Setup toggle
    if (setupToggleBtn) {
      setupToggleBtn.addEventListener('pointerup', () => { setSetupOpen(!setupOpen); saveSettings(); });
    }
    // Theme handlers
    if (themeSelectEl) themeSelectEl.addEventListener('change', () => {
      const overrides = (() => { try { return JSON.parse(themeOverridesEl.value||''); } catch { return {}; } })();
      applyTheme(themeSelectEl.value, overrides);
      saveSettings();
    }, { passive: true });
    if (themeOverridesEl) themeOverridesEl.addEventListener('change', () => {
      const overrides = (() => { try { return JSON.parse(themeOverridesEl.value||''); } catch { return {}; } })();
      applyTheme((themeSelectEl?.value||'dark'), overrides);
      saveSettings();
    }, { passive: true });
    // Font selector handler
    if (fontSelectEl) fontSelectEl.addEventListener('change', () => {
      applyFont(fontSelectEl.value);
    }, { passive: true });
    if (presetQuickSelect) presetQuickSelect.addEventListener('change', () => {
      applyPresetByKey(presetQuickSelect.value);
    }, { passive: true });
    if (openPresetSettingsBtn) openPresetSettingsBtn.addEventListener('pointerup', () => {
      const targetState = !setupOpen;
      setSetupOpen(targetState);
      if (targetState) {
        setupToggleBtn?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
      saveSettings();
    });
    if (optionalSettingsToggle) optionalSettingsToggle.addEventListener('pointerup', () => {
      setOptionalSettingsOpen(!optionalSettingsOpen);
      saveSettings();
    });
    if (systemPromptEl) systemPromptEl.addEventListener('input', () => {
      activePresetKey = guessPresetKeyFromPrompt(systemPromptEl.value);
      syncQuickPresetSelection();
    }, { passive: true, capture: true });
    loadSettings();

    // ---------- persona slots
    function loadSlots() {
      try {
        const raw = localStorage.getItem(SLOTS_KEY);
        if (!raw) return Array.from({length:5}, () => ({name:'', prompt:''}));
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr) || arr.length !== 5) return Array.from({length:5}, () => ({name:'', prompt:''}));
        return arr.map(x => ({ name: String(x.name||''), prompt: String(x.prompt||'') }));
      } catch {
        return Array.from({length:5}, () => ({name:'', prompt:''}));
      }
    }
    function saveSlots(slots) { localStorage.setItem(SLOTS_KEY, JSON.stringify(slots)); }
    function updateSlotUI(slots) {
      slotSelect.innerHTML = '';
      slots.forEach((s, i) => {
        const label = s.name ? `Slot ${i+1}: ${s.name}` : `Slot ${i+1}: (empty)`;
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = label;
        slotSelect.appendChild(opt);
      });
      if (slotSelect.options.length) slotSelect.value = slotSelect.options[0].value;
      updateQuickPresetOptions();
    }

    personaSlots = loadSlots();
    updateSlotUI(personaSlots);
    syncQuickPresetSelection();

    saveSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const current = personaSlots[idx] || {name:'', prompt:''};
      const suggested = current.name || (systemPromptEl.value.split('\n')[0].slice(0,48));
      const name = window.prompt('Name for this slot:', suggested) || suggested || `Persona ${idx+1}`;
      personaSlots[idx] = { name, prompt: systemPromptEl.value };
      activePresetKey = `slot:${idx}`;
      saveSlots(personaSlots);
      updateSlotUI(personaSlots);
      saveSettings();
    });

    loadSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const slot = personaSlots[idx];
      if (!slot || !slot.prompt) { alert('Empty slot.'); return; }
      systemPromptEl.value = slot.prompt;
      activePresetKey = `slot:${idx}`;
      syncQuickPresetSelection();
      saveSettings();
    });

    renameSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const slot = personaSlots[idx];
      if (!slot) return;
      const name = window.prompt('New name:', slot.name || `Persona ${idx+1}`);
      if (name != null) {
        personaSlots[idx].name = name.trim();
        saveSlots(personaSlots);
        updateSlotUI(personaSlots);
        saveSettings();
      }
    });

    clearSlotBtn.addEventListener('pointerup', () => {
      const idx = parseInt(slotSelect.value || '0', 10) || 0;
      const name = (personaSlots[idx]?.name || `Persona ${idx+1}`).trim() || `Persona ${idx+1}`;
      const ok = window.confirm(`Clear saved slot "${name}"? This cannot be undone.`);
      if (!ok) return;
      personaSlots[idx] = {name:'', prompt:''};
      if (activePresetKey === `slot:${idx}`) {
        activePresetKey = guessPresetKeyFromPrompt(systemPromptEl.value);
      }
      saveSlots(personaSlots);
      updateSlotUI(personaSlots);
      saveSettings();
    });

    // ---------- apply vendor preset
    vendorEl.addEventListener('change', () => {
      const p = vendorPresets[vendorEl.value] || {};
      if (p.apiBase) apiBaseEl.value = p.apiBase;
      if (p.extraHeaders) {
        try {
          const existing = parseJSONOrEmpty(extraHeadersEl.value);
          const merged = Object.assign({}, existing, p.extraHeaders);
          extraHeadersEl.value = JSON.stringify(merged);
        } catch {
          extraHeadersEl.value = JSON.stringify(p.extraHeaders);
        }
      }
      saveSettings();
      modelsStatus.textContent = 'Preset applied';
    }, { passive: true });

    // ---------- Scripture data and selectors
    let verses = [];
    function norm(s) { return String(s || '').trim().toLowerCase(); }
    function parseList(s) {
      if (!s) return null;
      const parts = String(s).split(',').map(t => t.trim()).filter(Boolean);
      return parts.length ? parts : null;
    }
    function filterVerses(rows, volumes, books) {
      const volSet = volumes ? new Set(volumes.map(v => norm(v))) : null;
      const bookSet = books ? new Set(books.map(b => norm(b))) : null;
      const out = [];
      for (const it of rows) {
        const vol = norm(it.volume_title);
        const book = norm(it.book_title);
        if (volSet && !volSet.has(vol)) continue;
        if (bookSet && !bookSet.has(book)) continue;
        out.push(it);
      }
      return out;
    }
    async function fetchJson(url) {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }
    function updateVolumeBookFields(rows) {
      try {
        const vols = Array.from(new Set(rows.map(r => String(r.volume_title || '').trim()).filter(Boolean)));
        const books = Array.from(new Set(rows.map(r => String(r.book_title || '').trim()).filter(Boolean)));
        if (vols.length) volumesEl.value = vols.join(',');
        // Do not force all books (can be long). Leave empty but hint via placeholder.
        booksEl.value = '';
        if (books.length) {
          const hint = books.slice(0, 8).join(',') + (books.length > 8 ? ' ...' : '');
          booksEl.placeholder = hint || 'Genesis,Exodus';
        }
      } catch {}
    }
    // Default JSON sources list
  const DEFAULT_JSON_SOURCES = [
      {
        label: 'Bible KJV (helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/bible_kjv.json'
      },
      {
        label: 'Tanakh (English, helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/tanakh_jps1917.json'
      },
      {
        label: 'LDS Standard Works (helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/lds_standard_works.json'
      },
      {
        label: 'Bhagavad Gita (helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/bhagavad_gita.json'
      },
      {
        label: 'Mahabharata (KMG, PD, helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/mahabharata_kmg.json'
      },
      {
        label: 'Quran (English, helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/quran_en.json'
      },
      {
        label: 'Dhammapada (English, helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/dhammapada_en.json'
      },
      {
        label: 'Tao Te Ching (Legge, helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/tao_te_ching_legge.json'
      },
      {
        label: 'Analects (Legge, helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/analects_legge.json'
      },
      {
        label: 'Upanishads (Principal 13, helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/upanishads_principal.json'
      },
      {
        label: 'Ramayana (Griffith, helix4u/Bible-Styler)',
        url: 'https://raw.githubusercontent.com/helix4u/Bible-Styler/main/ramayana_griffith.json'
      },
      { label: 'Custom URL...', url: '' }
    ];
    function initJsonPresetUI() {
      // populate options
      jsonPresetEl.innerHTML = '';
      DEFAULT_JSON_SOURCES.forEach((src, i) => {
        const opt = document.createElement('option');
        opt.value = src.url;
        opt.textContent = src.label;
        jsonPresetEl.appendChild(opt);
      });
      // select matching preset if any
      const current = (jsonUrlEl.value || '').trim();
      const match = DEFAULT_JSON_SOURCES.find(s => s.url && s.url === current);
      jsonPresetEl.value = match ? match.url : '';
      // on change, apply into the URL field
      jsonPresetEl.addEventListener('change', () => {
        const url = jsonPresetEl.value || '';
        if (url) jsonUrlEl.value = url;
        saveSettings();
      }, { passive: true });
    }
    initJsonPresetUI();
    function populateSelectorsFromData(rows) {
      const books = Array.from(new Set(rows.map(r => r.book_title)));
      bookSel.innerHTML = books.map(b => `<option value="${b}">${b}</option>`).join('');
      if (books.length) { bookSel.value = books[0]; populateChapters(); }
    }
    function populateChapters() {
      const b = bookSel.value;
      const chapters = Array.from(new Set(verses.filter(v => v.book_title === b).map(v => Number(v.chapter_number)))).sort((a,b)=>a-b);
      chapterSel.innerHTML = chapters.map(c => `<option value="${c}">${c}</option>`).join('');
      if (chapters.length) { chapterSel.value = chapters[0]; populateVerses(); }
    }
    function populateVerses() {
      const b = bookSel.value;
      const c = Number(chapterSel.value);
      const vs = verses
        .filter(v => v.book_title === b && Number(v.chapter_number) === c)
        .map(v => Number(v.verse_number))
        .sort((a,b)=>a-b);
      const prev = Number(verseSel.value);
      verseSel.innerHTML = vs.map(v => `<option value="${v}">${v}</option>`).join('');
      if (vs.includes(prev)) {
        verseSel.value = String(prev);
      } else if (vs.length) {
        verseSel.value = String(vs[0]);
      }
      updateSinglePlaceholder();
    }

    function updateSinglePlaceholder() {
      const b = bookSel.value;
      const c = Number(chapterSel.value);
      const vno = Number(verseSel.value);
      const txt = verses.find(v => v.book_title === b && Number(v.chapter_number) === c && Number(v.verse_number) === vno)?.scripture_text || '';
      // Show full original scripture text for mobile usability; do not truncate
      singleTextEl.placeholder = txt ? `JSON text: ${txt}` : 'No JSON text found';
    }

    function bindMobileSelect(sel, handler) {
      ['change','input','pointerup','click','blur'].forEach(ev => sel.addEventListener(ev, handler, { passive: true }));
    }

    async function loadJsonFromUrl() {
      try {
        statusEl.textContent = 'Fetching JSON...';
        const data = await fetchJson(jsonUrlEl.value);
        if (!Array.isArray(data) || !data.length) throw new Error('Expected JSON array');
        verses = data;
        statusEl.textContent = `Loaded ${data.length} rows`;
        populateSelectorsFromData(verses);
        updateVolumeBookFields(verses);
        saveSettings();
        return true;
      } catch (e) {
        statusEl.textContent = `Failed to load JSON ... ${e.message}`;
        return false;
      }
    }

    document.getElementById('loadJson').addEventListener('pointerup', loadJsonFromUrl);

    jsonFileEl.addEventListener('change', async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        if (!Array.isArray(data) || !data.length) throw new Error('Expected JSON array');
        verses = data;
        statusEl.textContent = `Loaded ${data.length} rows from file`;
        populateSelectorsFromData(verses);
        updateVolumeBookFields(verses);
        saveSettings();
      } catch (e) {
        statusEl.textContent = `Bad JSON file ... ${e.message}`;
      }
    });

    bindMobileSelect(bookSel, populateChapters);
    bindMobileSelect(chapterSel, populateVerses);
    bindMobileSelect(verseSel, updateSinglePlaceholder);

    // ---------- chat call (SSE or JSON)
    async function chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders }) {
      const headers = { 'Content-Type': 'application/json' };
      if (apiKey) {
        headers['Authorization'] = `Bearer ${apiKey}`;
        headers['X-API-Key'] = apiKey;
      }
      if (extraHeaders) Object.assign(headers, extraHeaders);

      const payload = {
        model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature,
        stream
      };
      if (stops && stops.length) payload.stop = stops;

      const resp = await fetch(apiBase, { method: 'POST', headers, body: JSON.stringify(payload) });
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`HTTP ${resp.status} ... ${txt.slice(0, 400)}`);
      }

      const ct = resp.headers.get('content-type') || '';
      if (!stream || ct.includes('application/json')) {
        const obj = await resp.json();
        return obj?.choices?.[0]?.message?.content?.trim() || '';
      }

      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buf = '';
      let out = '';
      for (;;) {
        const { value, done } = await reader.read();
        if (done) break;
        buf += decoder.decode(value, { stream: true });
        const parts = buf.split('\n\n');
        buf = parts.pop() || '';
        for (const chunk of parts) {
          const line = chunk.trim();
          if (!line) continue;
          const raw = line.startsWith('data: ') ? line.slice(6).trim() : line;
          if (raw === '[DONE]') { reader.cancel().catch(()=>{}); break; }
          try {
            const obj = JSON.parse(raw);
            const ch0 = obj.choices?.[0] || {};
            const piece = ch0.delta?.content ?? ch0.message?.content ?? '';
            if (piece) out += piece;
          } catch {}
        }
      }
      return out.trim();
    }

    function setStudyStatus(msg) {
      if (!studyStatusEl) return;
      studyStatusEl.textContent = msg;
      if (!msg) return;
      setTimeout(() => { if (studyStatusEl.textContent === msg) studyStatusEl.textContent = ''; }, 2000);
    }
    async function shareStudy() {
      try {
        const txt = (studyOutEl.textContent || '').trim();
        if (!txt) { setStudyStatus('Nothing to share'); return; }
        if (navigator.share) {
          const snippet = txt.length > 100000 ? txt.slice(0, 100000) : txt;
          try {
            await navigator.share({ title: 'Study Aids', text: snippet });
            setStudyStatus('Shared');
            return;
          } catch (err) {
            if (err && (err.name === 'AbortError' || err.name === 'NotAllowedError')) { setStudyStatus(''); return; }
          }
        }
        const ok = await copyToClipboard(txt);
        setStudyStatus(ok ? 'Copied (share unavailable)' : 'Share/copy failed');
      } catch (e) {
        setStudyStatus('Share failed');
      }
    }

    function parseOutAsMap() {
      const map = new Map();
      const lines = (outEl.textContent || '').split('\n').map(s => s.trim()).filter(Boolean);
      for (const ln of lines) {
        const m = ln.match(/^\[([^\]]+)\]\s*(.*)$/);
        if (m) map.set(m[1], m[2]);
      }
      return map;
    }

    function buildOriginalLines(scope) {
      const book = bookSel.value;
      const chapter = Number(chapterSel.value);
      const verseNo = Number(verseSel.value);
      if (!verses.length) return [];
      if (scope === 'verse') {
        const it = verses.find(v => v.book_title === book && Number(v.chapter_number) === chapter && Number(v.verse_number) === verseNo);
        if (!it) return [];
        const ref = verseRef(it);
        return [`[${ref}] ${String(it.scripture_text || '')}`];
      }
      if (scope === 'chapter') {
        return verses
          .filter(v => v.book_title === book && Number(v.chapter_number) === chapter)
          .sort((a,b)=>Number(a.verse_number)-Number(b.verse_number))
          .map(it => `[${verseRef(it)}] ${String(it.scripture_text || '')}`);
      }
      return [];
    }

    function buildStyledLines(scope) {
      const map = parseOutAsMap();
      if (!map.size) return [];
      if (scope === 'out') {
        return Array.from(map.entries()).map(([ref, body]) => `[${ref}] ${body}`);
      }
      const book = bookSel.value;
      const chapter = Number(chapterSel.value);
      const verseNo = Number(verseSel.value);
      const want = new Set();
      if (scope === 'verse') {
        const row = verses.find(v => v.book_title === book && Number(v.chapter_number) === chapter && Number(v.verse_number) === verseNo);
        if (row) want.add(verseRef(row));
      }
      if (scope === 'chapter') {
        verses
          .filter(v => v.book_title === book && Number(v.chapter_number) === chapter)
          .forEach(row => {
            const ref = verseRef(row);
            if (ref) want.add(ref);
          });
      }
      const out = [];
      for (const r of want) {
        if (map.has(r)) out.push(`[${r}] ${map.get(r)}`);
      }
      return out;
    }

    function makeStudyMessages({ preset, question, scope, contextMode, includeXrefs, xrefLimit, citationStyle }) {
      const originalLines = (contextMode === 'original' || contextMode === 'both') ? buildOriginalLines(scope) : [];
      const styledLines = (contextMode === 'styled' || contextMode === 'both') ? buildStyledLines(scope) : [];
      const ctx = [];
      if (styledLines.length) ctx.push('Styled passages:\n' + styledLines.join('\n'));
      if (originalLines.length) ctx.push('Original passages:\n' + originalLines.join('\n'));
      const contextBlock = ctx.join('\n\n');
      let sys = STUDY_PRESETS[preset] || STUDY_PRESETS.qa;
      // Detect corpus/tradition for cross-references constraint
      function corpusHint() {
        try {
          // Prefer explicit verse metadata when scope is verse/chapter
          const b = bookSel.value;
          const sample = verses.find(v => v.book_title === b);
          const vol = (sample?.volume_title || '').trim();
          const book = (sample?.book_title || '').trim();
          if (!vol) return '';
          if (vol === 'Quran') return 'Cross-references must come only from the Quran. Cite as SurahName S:V (e.g., Al-Baqarah 2:255).';
          if (vol === 'Bhagavad Gita') return 'Cross-references must come only from the Bhagavad Gita. Cite as Bhagavad Gita C:V (e.g., Bhagavad Gita 2:47).';
          if (vol === 'Buddhism') {
            if (book && book.indexOf('Dhammapada') >= 0) return 'Cross-references must come only from the Dhammapada. Cite as Dhammapada C:V.';
            return 'Keep cross-references within the same Buddhist text. Cite as [Book C:V].';
          }
          if (vol === 'Hinduism' && book && book.indexOf('Upanishad') >= 0) return 'Cross-references must come only from the Upanishads. Cite as Upanishads – Name C:V.';
          if (vol === 'Hinduism' && book && book.indexOf('Ramayana') >= 0) return 'Cross-references must come only from the Ramayana. Cite as Ramayana – Book C:V.';
          if (vol === 'Hinduism' && book && book.indexOf('Mahabharata') >= 0) return 'Cross-references must come only from the Mahabharata. Cite as Mahabharata – Book Section ¶V.';
          if (vol === 'Taoism' || book.indexOf('Tao Te Ching') >= 0) return 'Cross-references must come only from the Tao Te Ching. Cite as Tao Te Ching C:V.';
          if (vol === 'Confucianism' || book === 'Analects') return 'Cross-references must come only from the Analects. Cite as Analects B:S (Book:Saying).';
          if (vol === 'Torah' || vol === "Nevi'im" || vol === 'Ketuvim') return 'Cross-references must come only from the Tanakh (Hebrew Bible). Cite as [Book C:V].';
          if (vol === 'Old Testament' || vol === 'New Testament') return 'Cross-references must come only from the Bible. Cite as [Book C:V].';
          if (vol === 'Book of Mormon' || vol === 'Doctrine and Covenants' || vol === 'Pearl of Great Price') {
            return 'Cross-references must come only from the LDS Standard Works (Bible, Book of Mormon, Doctrine and Covenants, Pearl of Great Price). Cite as [Book C:V].';
          }
          return 'Keep cross-references within the same corpus as the provided passages.';
        } catch { return ''; }
      }
      const safeLimit = Number.isFinite(xrefLimit) ? Math.max(0, Math.min(12, xrefLimit)) : 0;
      const style = citationStyle || 'auto';
      const corpusGuidance = includeXrefs ? corpusHint() : '';
      const limitGuidance = includeXrefs
        ? (safeLimit > 0
          ? `Provide at most ${safeLimit} cross-reference${safeLimit === 1 ? '' : 's'} total.`
          : 'Only include a cross-reference when it adds clear, necessary insight.')
        : '';
      let styleGuidance = '';
      if (includeXrefs) {
        if (style === 'brackets') styleGuidance = 'Format cross-references like [Book C:V].';
        else if (style === 'colon') styleGuidance = 'Format cross-references like Book C:V (no brackets).';
        else if (style === 'narrative') styleGuidance = 'Write cross-references in words, e.g., "Book Chapter Verse".';
      }
      const xrefInstructions = [corpusGuidance, limitGuidance, styleGuidance].filter(Boolean).join('\n');
      if (includeXrefs && xrefInstructions) {
        sys = sys + '\n\n' + xrefInstructions;
      } else if (!includeXrefs) {
        sys = sys + '\n\nDo not invent cross-references unless explicitly requested.';
      }

      const promptParts = [];
      if (preset === 'qa') {
        const q = (question?.trim() || 'Provide a helpful study answer based on the passages.');
        promptParts.push(q);
        if (includeXrefs) {
          const qaNotes = [limitGuidance, styleGuidance].filter(Boolean);
          if (qaNotes.length) promptParts.push('Cross-reference preferences:\n' + qaNotes.join('\n'));
        }
      }
      const ask = promptParts.join('\n\n');
      const user = ask ? `${contextBlock}\n\n${ask}`.trim() : contextBlock.trim();
      return { system: sys, user };
    }

    // --- TTS (Web Speech API) ---
    const hasTTS = typeof window !== 'undefined' && 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
    if (!hasTTS) {
      if (readOutBtn) { readOutBtn.disabled = true; readOutBtn.title = 'Text-to-speech not supported in this browser'; }
      if (stopTtsBtn) { stopTtsBtn.disabled = true; }
    }
    let ttsActive = false;
    function splitIntoChunks(text, maxLen) {
      const out = [];
      const sents = text.split(/(?<=[\.\!\?])\s+/);
      let buf = '';
      for (const s of sents) {
        if ((buf + ' ' + s).trim().length > maxLen) { if (buf) out.push(buf.trim()); buf = s; }
        else { buf = (buf ? (buf + ' ' + s) : s); }
      }
      if (buf.trim()) out.push(buf.trim());
      return out;
    }
    function ttsStop() {
      if (!hasTTS) return;
      window.speechSynthesis.cancel();
      ttsActive = false;
      setOutStatus('TTS stopped');
    }
    async function ttsSpeak(text) {
      if (!hasTTS) return;
      if (!text) { setOutStatus('Nothing to read'); return; }
      // Avoid overlapping reads
      ttsStop();
      // Some engines have per-utterance limits; be conservative
      const chunks = splitIntoChunks(text, 1500);
      ttsActive = true;
      for (const chunk of chunks) {
        if (!ttsActive) break;
        const utt = new SpeechSynthesisUtterance(chunk);
        utt.rate = 1.0; // sane defaults
        utt.pitch = 1.0;
        await new Promise((resolve) => {
          utt.onend = resolve; utt.onerror = resolve;
          window.speechSynthesis.speak(utt);
        });
      }
      ttsActive = false;
      setOutStatus('TTS done');
    }
    if (readOutBtn) {
      readOutBtn.addEventListener('pointerup', async () => {
        try {
          const sel = (window.getSelection && (window.getSelection().toString().trim())) || '';
          const text = sel || (outEl.textContent || '').trim();
          await ttsSpeak(text);
        } catch (e) { setOutStatus('TTS error'); }
      });
    }
    if (stopTtsBtn) {
      stopTtsBtn.addEventListener('pointerup', ttsStop);
    }

    function makeUserPrompt(book, chapter, verse, text) {
      return `Reference: ${book} ${chapter}:${verse}\nText: "${normalizeAscii(text)}"`;
    }
    function postprocessLine(result, expectedPrefix) {
      if (!result) return expectedPrefix;
      const safe = expectedPrefix.slice(1, -1).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const rx = new RegExp('\\[' + safe + '\\][^\\n\\r]*');
      const m = result.match(rx);
      let s = m ? m[0] : result;
      s = sanitizeOneLine(s);
      if (!s.startsWith(expectedPrefix)) {
        const body = s.replace(/^[\[\("]+/, '').trim();
        s = `${expectedPrefix} ${body}`;
      }
      return s;
    }
    function bodyOk(line, expectedPrefix, minChars = 6) {
      const body = line.slice(expectedPrefix.length).trim();
      return body.length >= minChars;
    }

    // ---------- fetch models (robust)
    async function fetchModelsList() {
      const apiBase = apiBaseEl.value.trim();
      const key = apiKeyEl.value.trim();
      if (!apiBase) throw new Error('API base required');

      const headers = { 'Accept': 'application/json' };
      if (key) headers['Authorization'] = `Bearer ${key}`;
      try { Object.assign(headers, parseJSONOrEmpty(extraHeadersEl.value)); } catch {}

      const baseRoot = apiBase
        .replace(/\/chat\/completions$/i, '')
        .replace(/\/+$/, '');
      const hasV1 = /\/v1$/i.test(baseRoot);

      const candidates = [
        `${baseRoot}/models`,
        hasV1 ? null : `${baseRoot}/v1/models`
      ].filter(Boolean);

      const isOllama = /localhost:11434|127\.0\.0\.1:11434/.test(apiBase);
      if (isOllama) candidates.push(apiBase.replace(/\/v1\/chat\/completions$/,'') + '/api/tags');

      let lastErr = 'no models endpoint responded';
      for (const url of candidates) {
        try {
          const r = await fetch(url, { headers });
          if (!r.ok) { lastErr = `HTTP ${r.status} at ${url}`; continue; }
          const data = await r.json();
          if (data && Array.isArray(data.data)) {
            return data.data.map(m => m.id || m.name).filter(Boolean);
          } else if (data && Array.isArray(data.models)) {
            return data.models.map(m => m.id || m.name).filter(Boolean);
          }
        } catch (e) { lastErr = e.message || String(e); }
      }
      throw new Error(lastErr);
    }

    fetchModelsBtn.addEventListener('pointerup', async () => {
      modelsStatus.textContent = 'Loading models...';
      // Remember selections before refresh
      const savedSelect = (() => { try { return (JSON.parse(localStorage.getItem(SETTINGS_KEY))||{}).modelSelect || ''; } catch { return ''; } })();
      const prevSelect = modelSelectEl.value;
      modelSelectEl.innerHTML = '';
      try {
        const ids = await fetchModelsList();
        if (!ids.length) throw new Error('no models returned');
        ids.forEach(id => {
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = id;
          modelSelectEl.appendChild(opt);
        });
        // Keep saved or previous selection if still present, otherwise pick first
        let chosen = '';
        if (savedSelect && ids.includes(savedSelect)) chosen = savedSelect;
        else if (prevSelect && ids.includes(prevSelect)) chosen = prevSelect;
        else if (ids.length) chosen = ids[0];
        if (chosen) modelSelectEl.value = chosen;
        lastSelectedModel = modelSelectEl.value || lastSelectedModel;
        if (customModelToggle.checked) updateModelInputsVisibility();
        modelsStatus.textContent = `Loaded ${ids.length}`;
        saveSettings();
      } catch (e) {
        modelsStatus.textContent = `Failed ... ${e.message}`;
      }
    });

    // toggle custom model typing
    customModelToggle.addEventListener('change', () => {
      updateModelInputsVisibility();
      saveSettings();
    }, { passive: true });

    // ---------- batch run
    let abort = false;
    startBtn.addEventListener('pointerup', async () => {
      try {
        abort = false;
        outEl.textContent = '';
        downloadBtn.disabled = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        statusEl.textContent = 'Starting ...';
        saveSettings();

        if (!verses.length) {
          statusEl.textContent = 'No scripture JSON loaded yet. Click Fetch or choose a JSON file.';
          startBtn.disabled = false; stopBtn.disabled = true;
          return;
        }

        const vols = parseList(volumesEl.value);
        const books = parseList(booksEl.value);
        const filtered = filterVerses(verses, vols, books);
        if (!filtered.length) {
          statusEl.textContent = 'Filter removed everything.';
          startBtn.disabled = false; stopBtn.disabled = true;
          return;
        }

        const startIdx = parseInt(startIndexEl.value || '0', 10) || 0;
        const endIdxRaw = endIndexEl.value?.trim();
        const endIdx = endIdxRaw ? parseInt(endIdxRaw, 10) : filtered.length;

        const ctxPairs = Math.max(0, parseInt(ctxPairsEl.value || '0', 10) || 0);
        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!apiBase) throw new Error('API base required.');
        if (!model) throw new Error('Model required.');

        let history = [];
        let outputLines = [];

        const total = Math.min(endIdx, filtered.length);
        for (let i = startIdx; i < total; i++) {
          if (abort) break;
          const it = filtered[i];
          const book = String(it.book_title);
          const chapter = Number(it.chapter_number);
          const verse = Number(it.verse_number);
          const text = String(it.scripture_text);
          const ref = verseRef(it);

          const expectedPrefix = `[${ref}]`;
          const userPrompt = makeUserPrompt(book, chapter, verse, text);

          statusEl.textContent = `Processing ${i + 1} / ${total} ... ${ref}`;
          let raw = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });

          let line = postprocessLine(raw, expectedPrefix);
          if (!bodyOk(line, expectedPrefix)) {
            const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line2 = postprocessLine(raw2, expectedPrefix);
            if (bodyOk(line2, expectedPrefix)) line = line2;
          }

          const recentAssistant = history.filter(m => m.role === 'assistant').map(m => m.content);
          const recentStarts = new Set(recentAssistant.map(ln => openingNgram((ln.split(']', 1)[1] || ''))));
          const thisStart = openingNgram((line.split(']', 1)[1] || ''));
          if (ctxPairs > 0 && recentStarts.has(thisStart)) {
            const raw3 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(1.0, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line3 = postprocessLine(raw3, expectedPrefix);
            if (bodyOk(line3, expectedPrefix)) line = line3;
          }

          outputLines.push(line);
          outEl.textContent += line + '\n';

          history.push({ role: 'user', content: `Reference: ${ref}\nText: "${normalizeAscii(text)}"` });
          history.push({ role: 'assistant', content: line });

          // maintain recent context length
          if (history.length > ctxPairs * 2) history.splice(0, history.length - ctxPairs * 2);

          await new Promise(r => setTimeout(r, 40));
        }

        statusEl.textContent = abort ? 'Stopped.' : 'Done.';
        if (outputLines.length) {
          downloadBtn.disabled = false;
          downloadBtn.onclick = () => {
            const blob = new Blob([outputLines.join('\n') + '\n'], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'styled_bible.txt';
            a.click();
            URL.revokeObjectURL(a.href);
          };
        }
      } catch (e) {
        statusEl.textContent = `Error ... ${e.message}`;
      } finally {
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    });

    stopBtn.addEventListener('pointerup', () => { abort = true; });

    // ---------- output copy/share actions
    if (copyOutBtn) {
      copyOutBtn.addEventListener('pointerup', async () => {
        const txt = (outEl.textContent || '').trim();
        if (!txt) { setOutStatus('Nothing to copy'); return; }
        const ok = await copyToClipboard(txt);
        setOutStatus(ok ? 'Copied to clipboard' : 'Copy failed');
      });
    }
    if (shareOutBtn) {
      // Disable if text share is unsupported
      if (!('share' in navigator)) {
        shareOutBtn.disabled = true;
        shareOutBtn.title = 'Web Share API (text) not supported';
      }
      shareOutBtn.addEventListener('pointerup', shareOutput);
    }

    // ---------- study run
    if (runStudyBtn) {
      runStudyBtn.addEventListener('pointerup', async () => {
        try {
          studyStatusEl.textContent = 'Generating...';
          studyOutEl.textContent = '';
          const apiBase = apiBaseEl.value.trim();
          const apiKey = apiKeyEl.value.trim();
          const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
          const temperature = parseFloat(temperatureEl.value || '0.7') || 0.7;
          const stream = streamEl.value === 'true';
          const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
          if (!apiBase) throw new Error('API base required');
          if (!model) throw new Error('Model required');

          const preset = studyPresetEl.value;
          const question = studyQuestionEl.value;
          const scope = studyScopeEl.value;
          const contextMode = studyContextEl.value;
          const includeXrefs = !!studyCrossrefsEl.checked;
          const xrefLimit = Math.max(0, Math.min(12, parseInt(studyCrossrefLimitEl?.value || '4', 10) || 0));
          const citationStyle = (studyCitationStyleEl?.value || 'auto');
          const msgs = makeStudyMessages({ preset, question, scope, contextMode, includeXrefs, xrefLimit, citationStyle });

          const result = await chatOnce({
            apiBase,
            model,
            apiKey,
            systemPrompt: msgs.system,
            userPrompt: msgs.user,
            temperature,
            stream,
            stops,
            extraHeaders: parseJSONOrEmpty(extraHeadersEl.value)
          });
          studyOutEl.textContent = result || '(no result)';
          studyStatusEl.textContent = 'Done.';
        } catch (e) {
          studyStatusEl.textContent = `Error ... ${e.message}`;
        }
      });
    }
    if (copyStudyBtn) {
      copyStudyBtn.addEventListener('pointerup', async () => {
        const txt = (studyOutEl.textContent || '').trim();
        if (!txt) { studyStatusEl.textContent = 'Nothing to copy'; return; }
        const ok = await copyToClipboard(txt);
        studyStatusEl.textContent = ok ? 'Copied to clipboard' : 'Copy failed';
      });
    }
    if (shareStudyBtn) {
      if (!('share' in navigator)) {
        shareStudyBtn.disabled = true;
        shareStudyBtn.title = 'Web Share API (text) not supported';
      }
      shareStudyBtn.addEventListener('pointerup', shareStudy);
    }

    // Study TTS wiring
    if (!hasTTS) {
      if (readStudyBtn) { readStudyBtn.disabled = true; readStudyBtn.title = 'Text-to-speech not supported in this browser'; }
      if (stopStudyTtsBtn) { stopStudyTtsBtn.disabled = true; }
    }
    if (readStudyBtn) {
      readStudyBtn.addEventListener('pointerup', async () => {
        try {
          const sel = (window.getSelection && (window.getSelection().toString().trim())) || '';
          const text = sel || (studyOutEl.textContent || '').trim();
          await ttsSpeak(text);
        } catch (e) { studyStatusEl.textContent = 'TTS error'; }
      });
    }
    if (stopStudyTtsBtn) {
      stopStudyTtsBtn.addEventListener('pointerup', ttsStop);
    }

    // ---------- single verse run
    runSingleBtn.addEventListener('pointerup', async () => {
      try {
        singleStatus.textContent = 'Running...';
        // Clear output so single-verse result starts fresh
        outEl.textContent = '';
        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!verses.length) throw new Error('Load JSON first');
        if (!apiBase) throw new Error('API base required');
        if (!model) throw new Error('Model required');

        const book = bookSel.value;
        const chapter = Number(chapterSel.value);
        const verseNo = Number(verseSel.value);
        const row = verses.find(v => v.book_title === book && Number(v.chapter_number) === chapter && Number(v.verse_number) === verseNo);
        const fallback = row?.scripture_text || '';
        const srcText = singleTextEl.value.trim() || fallback;

        const userPrompt = makeUserPrompt(book, chapter, verseNo, srcText);
        const refObj = row || { book_title: book, chapter_number: chapter, verse_number: verseNo };
        const expectedPrefix = `[${verseRef(refObj)}]`;

        const raw = await chatOnce({
          apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value)
        });

        let line = postprocessLine(raw, expectedPrefix);
        if (!bodyOk(line, expectedPrefix)) {
          const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
          const line2 = postprocessLine(raw2, expectedPrefix);
          if (bodyOk(line2, expectedPrefix)) line = line2;
        }

        // Replace output with just this single result
        outEl.textContent = line + '\n';
        singleStatus.textContent = 'Done.';
      } catch (e) {
        singleStatus.textContent = `Error ... ${e.message}`;
      }
    });

    // ---------- single chapter run (chunked)
    let chunkState = { book: '', chapter: 0, nextIndex: 0, total: 0 };
    function resetChunkUI() {
      chunkState = { book: '', chapter: 0, nextIndex: 0, total: 0 };
      if (nextChunkBtn) {
        nextChunkBtn.style.display = 'none';
        nextChunkBtn.disabled = true;
        nextChunkBtn.textContent = 'Next chunk';
      }
    }
    if (bookSel) bookSel.addEventListener('change', () => { resetChunkUI(); });
    if (chapterSel) chapterSel.addEventListener('change', () => { resetChunkUI(); });

    async function runChapterChunk(startIndex, append) {
      try {
        singleStatus.textContent = 'Running chapter...';
        if (!append) outEl.textContent = '';

        const apiBase = apiBaseEl.value.trim();
        const apiKey = apiKeyEl.value.trim();
        const model = getActiveModelId() || 'qwen3-4b-instruct-2507';
        const temperature = parseFloat(temperatureEl.value || '0.9') || 0.9;
        const stream = streamEl.value === 'true';
        const stops = stopsEl.value.split(',').map(s => s.trim()).filter(Boolean);
        const systemPrompt = systemPromptEl.value;

        if (!verses.length) throw new Error('Load JSON first');
        if (!apiBase) throw new Error('API base required');
        if (!model) throw new Error('Model required');

        const book = bookSel.value;
        const chapter = Number(chapterSel.value);

        const rows = verses
          .filter(v => v.book_title === book && Number(v.chapter_number) === chapter)
          .sort((a,b) => Number(a.verse_number) - Number(b.verse_number));
        if (!rows.length) throw new Error('No verses for this chapter');

        const maxPer = Math.max(1, parseInt(maxPerRunEl?.value || '50', 10) || 50);
        const begin = Math.max(0, Math.min(startIndex || 0, rows.length));
        const end = Math.min(rows.length, begin + maxPer);

        const ctxPairs = Math.max(0, parseInt(ctxPairsEl.value || '0', 10) || 0);
        let history = [];

        for (let i = begin; i < end; i++) {
          const it = rows[i];
          const verseNo = Number(it.verse_number);
          const text = String(it.scripture_text || '');
          const ref = verseRef(it);

          singleStatus.textContent = `Processing ${i + 1} / ${rows.length} ... ${ref}`;

          const userPrompt = makeUserPrompt(book, chapter, verseNo, text);
          const expectedPrefix = `[${ref}]`;

          let raw = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature, stream, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
          let line = postprocessLine(raw, expectedPrefix);

          if (!bodyOk(line, expectedPrefix)) {
            const raw2 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(0.9, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line2 = postprocessLine(raw2, expectedPrefix);
            if (bodyOk(line2, expectedPrefix)) line = line2;
          }

          const recentAssistant = history.filter(m => m.role === 'assistant').map(m => m.content);
          const recentStarts = new Set(recentAssistant.map(ln => openingNgram((ln.split(']', 1)[1] || ''))));
          const thisStart = openingNgram((line.split(']', 1)[1] || ''));
          if (ctxPairs > 0 && recentStarts.has(thisStart)) {
            const raw3 = await chatOnce({ apiBase, model, apiKey, systemPrompt, userPrompt, temperature: Math.max(1.0, temperature), stream: false, stops, extraHeaders: parseJSONOrEmpty(extraHeadersEl.value) });
            const line3 = postprocessLine(raw3, expectedPrefix);
            if (bodyOk(line3, expectedPrefix)) line = line3;
          }

          outEl.textContent += line + '\n';

          history.push({ role: 'user', content: `Reference: ${ref}\nText: "${normalizeAscii(text)}"` });
          history.push({ role: 'assistant', content: line });
          if (history.length > ctxPairs * 2) history.splice(0, history.length - ctxPairs * 2);
          await new Promise(r => setTimeout(r, 40));
        }

        chunkState = { book, chapter, nextIndex: end, total: rows.length };
        if (nextChunkBtn) {
          if (end < rows.length) {
            nextChunkBtn.style.display = 'inline-block';
            nextChunkBtn.disabled = false;
            nextChunkBtn.textContent = `Next chunk (${end + 1}–${Math.min(rows.length, end + maxPer)})`;
            singleStatus.textContent = `Chunk ${begin + 1}–${end} done. ${rows.length - end} remaining.`;
          } else {
            nextChunkBtn.style.display = 'none';
            nextChunkBtn.disabled = true;
            nextChunkBtn.textContent = 'Next chunk';
            singleStatus.textContent = 'Done.';
          }
        }
      } catch (e) {
        singleStatus.textContent = `Error ... ${e.message}`;
      }
    }

    runChapterBtn.addEventListener('pointerup', async () => {
      resetChunkUI();
      await runChapterChunk(0, /*append*/false);
    });

    if (nextChunkBtn) {
      nextChunkBtn.addEventListener('pointerup', async () => {
        if (!chunkState.book || chunkState.book !== bookSel.value || Number(chapterSel.value) !== chunkState.chapter) {
          await runChapterChunk(0, /*append*/false);
        } else {
          const shouldClear = !!(clearBeforeNextEl && clearBeforeNextEl.checked);
          await runChapterChunk(chunkState.nextIndex || 0, /*append*/!shouldClear);
        }
      });
    }

    // initial UI wiring
    function initModelSelectUI() {
      if (!modelSelectEl.options.length) {
        // minimal starter list so selector is usable on first load, esp. mobile
        ['gpt-4.1-mini','gpt-4.1-nano','qwen3-4b-instruct-2507','gpt-4o-mini','gpt-4o','llama-3.1-8b-instruct','mistral-small-latest']
          .forEach(id => {
            const opt = document.createElement('option');
            opt.value = id; opt.textContent = id;
            modelSelectEl.appendChild(opt);
          });
      }
      // restore selection if saved
      const saved = (() => {
        try { return (JSON.parse(localStorage.getItem(SETTINGS_KEY))||{}).modelSelect || ''; } catch { return ''; }
      })();
      if (saved) {
        const found = Array.from(modelSelectEl.options).some(o => o.value === saved);
        modelSelectEl.value = found ? saved : modelSelectEl.options[0].value;
      }
    }
    initModelSelectUI();

    // custom model toggle visibility correction on load
    updateModelInputsVisibility();

    // Auto fetch last JSON on first load if enabled
    (async () => {
      try {
        const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
        if (s && s.autoFetchJson === 'true' && (jsonUrlEl.value || '').trim()) {
          await loadJsonFromUrl();
        }
      } catch {}
    })();
  </script>
</body>
</html>


